\hypertarget{_e_f___i2_c_8h}{}\doxysection{EF\+\_\+\+I2\+C.\+h File Reference}
\label{_e_f___i2_c_8h}\index{EF\_I2C.h@{EF\_I2C.h}}


C header file for I2C APIs which contains the function prototypes.  


{\ttfamily \#include \char`\"{}EF\+\_\+\+I2\+C\+\_\+regs.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}EF\+\_\+\+Driver\+\_\+\+Common.\+h\char`\"{}}\newline
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{_e_f___i2_c_8h_a6c5c548b64cb71bdc4b7021d5bc0ac40}{EF\+\_\+\+I2\+C\+\_\+\+COMMAND\+\_\+\+REG\+\_\+\+CMD\+\_\+\+CORRECT\+\_\+\+MASK}}~((uint32\+\_\+t)0x\+FFFFE080)
\item 
\#define \mbox{\hyperlink{_e_f___i2_c_8h_a5fafabd8b05d8b014293383617d961d5}{EF\+\_\+\+I2\+C\+\_\+\+PR\+\_\+\+MAX\+\_\+\+VALUE}}~((uint32\+\_\+t)0x0000\+FFFF)
\item 
\#define \mbox{\hyperlink{_e_f___i2_c_8h_ab1fdffc2f516327a24051b9b7f6061f5}{EF\+\_\+\+I2\+C\+\_\+\+IM\+\_\+\+REG\+\_\+\+MAX\+\_\+\+VALUE}}~((uint32\+\_\+t)0x000001\+FF)
\item 
\#define \mbox{\hyperlink{_e_f___i2_c_8h_a602154856cc6d698f903f4e5c2b0a59f}{EF\+\_\+\+I2\+C\+\_\+\+IC\+\_\+\+REG\+\_\+\+MAX\+\_\+\+VALUE}}~((uint32\+\_\+t)0x000001\+FF)
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a8cd33e8dde8407bb760d8a9e06548dea}{EF\+\_\+\+I2\+C\+\_\+set\+Gclk\+Enable}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint32\+\_\+t value)
\begin{DoxyCompactList}\small\item\em Sets the GCLK enable bit in the I2C register to a certain value. \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a2286c60de589dcecb0fc78a48187440b}{EF\+\_\+\+I2\+C\+\_\+set\+Command\+Reg}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint32\+\_\+t value)
\begin{DoxyCompactList}\small\item\em Sets the command register of the I2C controller. \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_ac5ca754457eaaeeab83e607fd78039e9}{EF\+\_\+\+I2\+C\+\_\+set\+Command\+Reg\+Non\+Blocking}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint32\+\_\+t value, bool $\ast$command\+\_\+sent)
\begin{DoxyCompactList}\small\item\em Writes a command value to the I2C command register (non-\/blocking). \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a97ff9205de09e49d12dc62eb1acdcf62}{EF\+\_\+\+I2\+C\+\_\+get\+Data\+Valid}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, bool $\ast$data\+\_\+valid)
\begin{DoxyCompactList}\small\item\em Reads the data valid flag from the I2C data register. \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a20ba0e48023589b93dc8fe15519c5482}{EF\+\_\+\+I2\+C\+\_\+set\+Data\+Last}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c)
\begin{DoxyCompactList}\small\item\em Sets the data last flag in the I2C data register. \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a95c96062892f3d3061365eb5d6f83dfe}{EF\+\_\+\+I2\+C\+\_\+get\+Data\+Last}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, bool $\ast$data\+\_\+last)
\begin{DoxyCompactList}\small\item\em Reads the data last flag from the I2C data register. \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a824f4aaa04cf1518f65a558c67172fdd}{EF\+\_\+\+I2\+C\+\_\+set\+Prescaler}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint32\+\_\+t value)
\begin{DoxyCompactList}\small\item\em Sets the I2C prescaler value. \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a8fa9bab21502620a499c6f943fc69c4c}{EF\+\_\+\+I2\+C\+\_\+get\+Prescaler}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint32\+\_\+t $\ast$prescaler\+\_\+value)
\begin{DoxyCompactList}\small\item\em Gets the I2C prescaler value. \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a8efd0e0e84b49d60edbea6c2513929a5}{EF\+\_\+\+I2\+C\+\_\+get\+RIS}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint32\+\_\+t $\ast$ris\+\_\+value)
\begin{DoxyCompactList}\small\item\em Reads the Raw Interrupt Status (RIS) register. \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_aa87448a542b497393695dca2acc6d6b8}{EF\+\_\+\+I2\+C\+\_\+get\+MIS}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint32\+\_\+t $\ast$mis\+\_\+value)
\begin{DoxyCompactList}\small\item\em Reads the Masked Interrupt Status (MIS) register. \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_ac9a53ca41924b84ebf52d2b659c029c7}{EF\+\_\+\+I2\+C\+\_\+set\+IM}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint32\+\_\+t mask)
\begin{DoxyCompactList}\small\item\em Sets the Interrupt Mask (IM) register. \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_ac4509f632d8b0b1157ec42828a957600}{EF\+\_\+\+I2\+C\+\_\+get\+IM}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint32\+\_\+t $\ast$im\+\_\+value)
\begin{DoxyCompactList}\small\item\em Reads the Interrupt Mask (IM) register. \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a69c76d64d9e2e6d29d53026b0fa1055c}{EF\+\_\+\+I2\+C\+\_\+is\+Busy}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, bool $\ast$is\+\_\+busy)
\begin{DoxyCompactList}\small\item\em Checks if the I2C peripheral is busy. \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a14e5de684a330a987584ba5219bf8304}{EF\+\_\+\+I2\+C\+\_\+is\+Command\+FIFOAvailable}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, bool $\ast$is\+\_\+available)
\begin{DoxyCompactList}\small\item\em Checks if the command FIFO is available. \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_aba9df55dc50dffa193d8990d9d3354b3}{EF\+\_\+\+I2\+C\+\_\+is\+Write\+FIFOAvailable}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, bool $\ast$is\+\_\+available)
\begin{DoxyCompactList}\small\item\em Checks if the write FIFO is available. \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a463bfb817bed4b5d06308211df98c7b4}{EF\+\_\+\+I2\+C\+\_\+is\+Read\+FIFOAvailable}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, bool $\ast$is\+\_\+available)
\begin{DoxyCompactList}\small\item\em Checks if the read FIFO is available. \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a374bdcd7a2d9994dd762b93260e7e988}{EF\+\_\+\+I2\+C\+\_\+send\+Write\+Command}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint8\+\_\+t addr)
\begin{DoxyCompactList}\small\item\em Sends a write command to the I2C device (blocking). \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a1ca44050fd31a0970d9a843ce2b660b7}{EF\+\_\+\+I2\+C\+\_\+send\+Write\+Command\+Non\+Blocking}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint8\+\_\+t addr, bool $\ast$command\+\_\+sent)
\begin{DoxyCompactList}\small\item\em Sends a write command to the I2C device (non-\/blocking). \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a5a4eefaa77952dce9da7af76b06e8d90}{EF\+\_\+\+I2\+C\+\_\+send\+Read\+Command}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint8\+\_\+t addr)
\begin{DoxyCompactList}\small\item\em Sends a read command to the I2C device (blocking). \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_ad761e01240a00cd0a0163838aa52fbf3}{EF\+\_\+\+I2\+C\+\_\+send\+Read\+Command\+Non\+Blocking}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint8\+\_\+t addr, bool $\ast$command\+\_\+sent)
\begin{DoxyCompactList}\small\item\em Sends a read command to the I2C device (non-\/blocking). \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_ad1fa3cec145bfbd8027e0370137c1b9d}{EF\+\_\+\+I2\+C\+\_\+send\+Start\+Command}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c)
\begin{DoxyCompactList}\small\item\em Sends a start condition on the I2C bus (blocking). \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a5895919e916705ee1082efade9f1488e}{EF\+\_\+\+I2\+C\+\_\+send\+Start\+Command\+Non\+Blocking}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, bool $\ast$command\+\_\+sent)
\begin{DoxyCompactList}\small\item\em Sends a start condition on the I2C bus (non-\/blocking). \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a4545f7e33e2e35e7b100b6f3857433bd}{EF\+\_\+\+I2\+C\+\_\+send\+Stop\+Command}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c)
\begin{DoxyCompactList}\small\item\em Sends a stop condition on the I2C bus (blocking). \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_adc35bddf018b22d9f822442360d9a1e5}{EF\+\_\+\+I2\+C\+\_\+send\+Stop\+Command\+Non\+Blocking}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, bool $\ast$command\+\_\+sent)
\begin{DoxyCompactList}\small\item\em Sends a stop condition on the I2C bus (non-\/blocking). \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_acfba97829c658e87ce338d95ab35cd6a}{EF\+\_\+\+I2\+C\+\_\+send\+Write\+Multiple\+Command}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint8\+\_\+t addr)
\begin{DoxyCompactList}\small\item\em Sends a \char`\"{}write multiple\char`\"{} command on the I2C bus (blocking). \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a4e0baaf0ed013abb939201fe71e179ae}{EF\+\_\+\+I2\+C\+\_\+send\+Write\+Multiple\+Command\+Non\+Blocking}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint8\+\_\+t addr, bool $\ast$command\+\_\+sent)
\begin{DoxyCompactList}\small\item\em Sends a \char`\"{}write multiple\char`\"{} command on the I2C bus (non-\/blocking). \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a2145a943f79505d4c057bc6958d034eb}{EF\+\_\+\+I2\+C\+\_\+write\+Data\+To\+Write\+FIFO}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint8\+\_\+t data)
\begin{DoxyCompactList}\small\item\em Writes data to the I2C Write FIFO (blocking). \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a9cf8cd0c4282ed5cc45954c6de74cae8}{EF\+\_\+\+I2\+C\+\_\+write\+Data\+To\+Write\+FIFONon\+Blocking}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint8\+\_\+t data, bool $\ast$data\+\_\+written)
\begin{DoxyCompactList}\small\item\em Writes data to the I2C Write FIFO (non-\/blocking). \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a1d9931eb963c13f5bbc96e2ba3c5bdab}{EF\+\_\+\+I2\+C\+\_\+read\+Data\+From\+Read\+FIFO}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint8\+\_\+t $\ast$data)
\begin{DoxyCompactList}\small\item\em Reads data from the I2C Read FIFO (blocking). \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_abc156cb4e2acec2cc205775b7ce3fccd}{EF\+\_\+\+I2\+C\+\_\+read\+Data\+From\+Read\+FIFONon\+Blocking}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint8\+\_\+t $\ast$data, bool $\ast$data\+\_\+read)
\begin{DoxyCompactList}\small\item\em Reads data from the I2C Read FIFO (non-\/blocking). \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a2b86143755c8196c79b8eeb89299a101}{EF\+\_\+\+I2\+C\+\_\+transmit\+Byte}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint8\+\_\+t data, uint8\+\_\+t addr)
\begin{DoxyCompactList}\small\item\em Transmits a single byte to a specified I2C address (blocking). \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a33dc1953f3b3819bf3c2c88191f80b03}{EF\+\_\+\+I2\+C\+\_\+transmit\+Byte\+Non\+Blocking}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint8\+\_\+t data, uint8\+\_\+t addr, bool $\ast$transmitted)
\begin{DoxyCompactList}\small\item\em Transmits a single byte to a specified I2C address (non-\/blocking). \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a0689bd62e532fda19ee62cd4b45b65c5}{EF\+\_\+\+I2\+C\+\_\+receive\+Byte}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint8\+\_\+t $\ast$data, uint8\+\_\+t addr)
\begin{DoxyCompactList}\small\item\em Receives a single byte from a specified I2C address (blocking). \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a13b810bd29c715c8698c77e8991d5913}{EF\+\_\+\+I2\+C\+\_\+receive\+Byte\+Non\+Blocking}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint8\+\_\+t $\ast$data, uint8\+\_\+t addr, bool $\ast$received)
\begin{DoxyCompactList}\small\item\em Receives a single byte from a specified I2C address (non-\/blocking). \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_aee77f1eec83d3dd4b709eeedc9ede05d}{EF\+\_\+\+I2\+C\+\_\+transmit\+Char\+Arr}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint8\+\_\+t $\ast$data, uint32\+\_\+t data\+\_\+length, uint8\+\_\+t addr)
\begin{DoxyCompactList}\small\item\em Transmits an array of bytes to a specified I2C address (blocking). \end{DoxyCompactList}\item 
\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \mbox{\hyperlink{_e_f___i2_c_8h_a82de40473f83b733860a491e825bfa2c}{EF\+\_\+\+I2\+C\+\_\+recieve\+Char\+Arr}} (\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} i2c, uint8\+\_\+t $\ast$data, uint32\+\_\+t data\+\_\+length, uint8\+\_\+t addr)
\begin{DoxyCompactList}\small\item\em Receives an array of bytes from a specified I2C address (blocking). \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
C header file for I2C APIs which contains the function prototypes. 



\doxysubsection{Macro Definition Documentation}
\mbox{\Hypertarget{_e_f___i2_c_8h_a6c5c548b64cb71bdc4b7021d5bc0ac40}\label{_e_f___i2_c_8h_a6c5c548b64cb71bdc4b7021d5bc0ac40}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_COMMAND\_REG\_CMD\_CORRECT\_MASK@{EF\_I2C\_COMMAND\_REG\_CMD\_CORRECT\_MASK}}
\index{EF\_I2C\_COMMAND\_REG\_CMD\_CORRECT\_MASK@{EF\_I2C\_COMMAND\_REG\_CMD\_CORRECT\_MASK}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_COMMAND\_REG\_CMD\_CORRECT\_MASK}{EF\_I2C\_COMMAND\_REG\_CMD\_CORRECT\_MASK}}
{\footnotesize\ttfamily \#define EF\+\_\+\+I2\+C\+\_\+\+COMMAND\+\_\+\+REG\+\_\+\+CMD\+\_\+\+CORRECT\+\_\+\+MASK~((uint32\+\_\+t)0x\+FFFFE080)}

\mbox{\Hypertarget{_e_f___i2_c_8h_a602154856cc6d698f903f4e5c2b0a59f}\label{_e_f___i2_c_8h_a602154856cc6d698f903f4e5c2b0a59f}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_IC\_REG\_MAX\_VALUE@{EF\_I2C\_IC\_REG\_MAX\_VALUE}}
\index{EF\_I2C\_IC\_REG\_MAX\_VALUE@{EF\_I2C\_IC\_REG\_MAX\_VALUE}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_IC\_REG\_MAX\_VALUE}{EF\_I2C\_IC\_REG\_MAX\_VALUE}}
{\footnotesize\ttfamily \#define EF\+\_\+\+I2\+C\+\_\+\+IC\+\_\+\+REG\+\_\+\+MAX\+\_\+\+VALUE~((uint32\+\_\+t)0x000001\+FF)}

\mbox{\Hypertarget{_e_f___i2_c_8h_ab1fdffc2f516327a24051b9b7f6061f5}\label{_e_f___i2_c_8h_ab1fdffc2f516327a24051b9b7f6061f5}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_IM\_REG\_MAX\_VALUE@{EF\_I2C\_IM\_REG\_MAX\_VALUE}}
\index{EF\_I2C\_IM\_REG\_MAX\_VALUE@{EF\_I2C\_IM\_REG\_MAX\_VALUE}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_IM\_REG\_MAX\_VALUE}{EF\_I2C\_IM\_REG\_MAX\_VALUE}}
{\footnotesize\ttfamily \#define EF\+\_\+\+I2\+C\+\_\+\+IM\+\_\+\+REG\+\_\+\+MAX\+\_\+\+VALUE~((uint32\+\_\+t)0x000001\+FF)}

\mbox{\Hypertarget{_e_f___i2_c_8h_a5fafabd8b05d8b014293383617d961d5}\label{_e_f___i2_c_8h_a5fafabd8b05d8b014293383617d961d5}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_PR\_MAX\_VALUE@{EF\_I2C\_PR\_MAX\_VALUE}}
\index{EF\_I2C\_PR\_MAX\_VALUE@{EF\_I2C\_PR\_MAX\_VALUE}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_PR\_MAX\_VALUE}{EF\_I2C\_PR\_MAX\_VALUE}}
{\footnotesize\ttfamily \#define EF\+\_\+\+I2\+C\+\_\+\+PR\+\_\+\+MAX\+\_\+\+VALUE~((uint32\+\_\+t)0x0000\+FFFF)}



\doxysubsection{Function Documentation}
\mbox{\Hypertarget{_e_f___i2_c_8h_a95c96062892f3d3061365eb5d6f83dfe}\label{_e_f___i2_c_8h_a95c96062892f3d3061365eb5d6f83dfe}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_getDataLast@{EF\_I2C\_getDataLast}}
\index{EF\_I2C\_getDataLast@{EF\_I2C\_getDataLast}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_getDataLast()}{EF\_I2C\_getDataLast()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+get\+Data\+Last (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{bool $\ast$}]{data\+\_\+last }\end{DoxyParamCaption})}



Reads the data last flag from the I2C data register. 

This function retrieves the current state of the data last flag in the I2C data register. The flag indicates whether the current data is the last in an I2C transaction.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & An \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}, which points to the base memory address of I2C registers. \mbox{\hyperlink{_e_f___i2_c__regs_8h_ab0d3f158914422e7299a70fcd51e6141}{EF\+\_\+\+I2\+C\+\_\+\+TYPE}} is a structure that contains the I2C registers. \\
\hline
\mbox{\texttt{ out}}  & {\em data\+\_\+last} & A pointer to a boolean variable where the state of the data last flag will be stored. The value is set to {\ttfamily true} if the data is the last in the transaction, or {\ttfamily false} otherwise.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a97ff9205de09e49d12dc62eb1acdcf62}\label{_e_f___i2_c_8h_a97ff9205de09e49d12dc62eb1acdcf62}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_getDataValid@{EF\_I2C\_getDataValid}}
\index{EF\_I2C\_getDataValid@{EF\_I2C\_getDataValid}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_getDataValid()}{EF\_I2C\_getDataValid()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+get\+Data\+Valid (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{bool $\ast$}]{data\+\_\+valid }\end{DoxyParamCaption})}



Reads the data valid flag from the I2C data register. 

This function retrieves the current state of the data valid flag in the I2C data register. The flag indicates whether the data is valid for an I2C transaction.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & An \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}, which points to the base memory address of I2C registers. \mbox{\hyperlink{_e_f___i2_c__regs_8h_ab0d3f158914422e7299a70fcd51e6141}{EF\+\_\+\+I2\+C\+\_\+\+TYPE}} is a structure that contains the I2C registers. \\
\hline
\mbox{\texttt{ out}}  & {\em data\+\_\+valid} & A pointer to a boolean variable where the state of the data valid flag will be stored. The value is set to {\ttfamily true} if the data is valid, or {\ttfamily false} otherwise.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_ac4509f632d8b0b1157ec42828a957600}\label{_e_f___i2_c_8h_ac4509f632d8b0b1157ec42828a957600}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_getIM@{EF\_I2C\_getIM}}
\index{EF\_I2C\_getIM@{EF\_I2C\_getIM}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_getIM()}{EF\_I2C\_getIM()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+get\+IM (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint32\+\_\+t $\ast$}]{im\+\_\+value }\end{DoxyParamCaption})}



Reads the Interrupt Mask (IM) register. 

This function reads the interrupt mask register (IM) of the I2C peripheral. The IM register contains a mask value that determines which interrupt sources are enabled. It shows the status of interrupt enablement for various interrupt sources. IM Register Breakdown$\ast$$\ast$\+:
\begin{DoxyItemize}
\item Bit 0\+: MISS\+\_\+\+ACK -\/ Slave ACK is missed
\item Bit 1\+: CMDE -\/ Command FIFO is Empty
\item Bit 2\+: CMDF -\/ Command FIFO is Full
\item Bit 3\+: CMDOVF -\/ Command FIFO overflow; write 1 to clear
\item Bit 4\+: WRE -\/ Write FIFO is Empty
\item Bit 5\+: WRF -\/ Write FIFO is Full
\item Bit 6\+: WROVF -\/ Write FIFO overflow; write 1 to clear
\item Bit 7\+: RDE -\/ Read FIFO is Empty
\item Bit 8\+: RDF -\/ Read FIFO is Full
\item Bits \mbox{[}9-\/31\mbox{]}\+: Reserved. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & An \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}, which points to the base memory address of I2C registers. \mbox{\hyperlink{_e_f___i2_c__regs_8h_ab0d3f158914422e7299a70fcd51e6141}{EF\+\_\+\+I2\+C\+\_\+\+TYPE}} is a structure that contains the I2C registers. \\
\hline
\mbox{\texttt{ out}}  & {\em im\+\_\+value} & A pointer to a 32-\/bit variable where the interrupt mask value will be stored.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}

\end{DoxyItemize}\mbox{\Hypertarget{_e_f___i2_c_8h_aa87448a542b497393695dca2acc6d6b8}\label{_e_f___i2_c_8h_aa87448a542b497393695dca2acc6d6b8}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_getMIS@{EF\_I2C\_getMIS}}
\index{EF\_I2C\_getMIS@{EF\_I2C\_getMIS}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_getMIS()}{EF\_I2C\_getMIS()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+get\+MIS (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint32\+\_\+t $\ast$}]{mis\+\_\+value }\end{DoxyParamCaption})}



Reads the Masked Interrupt Status (MIS) register. 

This function reads the masked interrupt status register (MIS) of the I2C peripheral. MIS Register Breakdown$\ast$$\ast$\+:
\begin{DoxyItemize}
\item Bit 0\+: MISS\+\_\+\+ACK -\/ Slave ACK is missed
\item Bit 1\+: CMDE -\/ Command FIFO is Empty
\item Bit 2\+: CMDF -\/ Command FIFO is Full
\item Bit 3\+: CMDOVF -\/ Command FIFO overflow; write 1 to clear
\item Bit 4\+: WRE -\/ Write FIFO is Empty
\item Bit 5\+: WRF -\/ Write FIFO is Full
\item Bit 6\+: WROVF -\/ Write FIFO overflow; write 1 to clear
\item Bit 7\+: RDE -\/ Read FIFO is Empty
\item Bit 8\+: RDF -\/ Read FIFO is Full
\item Bits \mbox{[}9-\/31\mbox{]}\+: Reserved.
\end{DoxyItemize}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & An \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}, which points to the base memory address of I2C registers. \mbox{\hyperlink{_e_f___i2_c__regs_8h_ab0d3f158914422e7299a70fcd51e6141}{EF\+\_\+\+I2\+C\+\_\+\+TYPE}} is a structure that contains the I2C registers. \\
\hline
\mbox{\texttt{ out}}  & {\em mis\+\_\+value} & A pointer to a 32-\/bit variable where the masked interrupt status will be stored.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a8fa9bab21502620a499c6f943fc69c4c}\label{_e_f___i2_c_8h_a8fa9bab21502620a499c6f943fc69c4c}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_getPrescaler@{EF\_I2C\_getPrescaler}}
\index{EF\_I2C\_getPrescaler@{EF\_I2C\_getPrescaler}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_getPrescaler()}{EF\_I2C\_getPrescaler()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+get\+Prescaler (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint32\+\_\+t $\ast$}]{prescaler\+\_\+value }\end{DoxyParamCaption})}



Gets the I2C prescaler value. 

This function reads the current prescaler value from the I2C peripheral. The prescaler determines the clock frequency for the I2C communication.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & An \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}, which points to the base memory address of I2C registers. \mbox{\hyperlink{_e_f___i2_c__regs_8h_ab0d3f158914422e7299a70fcd51e6141}{EF\+\_\+\+I2\+C\+\_\+\+TYPE}} is a structure that contains the I2C registers. \\
\hline
\mbox{\texttt{ out}}  & {\em prescaler\+\_\+value} & A pointer to a 32-\/bit variable where the current prescaler value will be stored.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a8efd0e0e84b49d60edbea6c2513929a5}\label{_e_f___i2_c_8h_a8efd0e0e84b49d60edbea6c2513929a5}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_getRIS@{EF\_I2C\_getRIS}}
\index{EF\_I2C\_getRIS@{EF\_I2C\_getRIS}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_getRIS()}{EF\_I2C\_getRIS()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+get\+RIS (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint32\+\_\+t $\ast$}]{ris\+\_\+value }\end{DoxyParamCaption})}



Reads the Raw Interrupt Status (RIS) register. 

This function reads the raw interrupt status register (RIS) of the I2C peripheral. The RIS register provides raw interrupt status flags indicating various conditions within the I2C communication. These flags include information such as FIFO states and errors.

RIS Register Breakdown$\ast$$\ast$\+:
\begin{DoxyItemize}
\item Bit 0\+: MISS\+\_\+\+ACK -\/ Slave ACK is missed
\item Bit 1\+: CMDE -\/ Command FIFO is Empty
\item Bit 2\+: CMDF -\/ Command FIFO is Full
\item Bit 3\+: CMDOVF -\/ Command FIFO overflow; write 1 to clear
\item Bit 4\+: WRE -\/ Write FIFO is Empty
\item Bit 5\+: WRF -\/ Write FIFO is Full
\item Bit 6\+: WROVF -\/ Write FIFO overflow; write 1 to clear
\item Bit 7\+: RDE -\/ Read FIFO is Empty
\item Bit 8\+: RDF -\/ Read FIFO is Full
\item Bits \mbox{[}9-\/31\mbox{]}\+: Reserved.
\end{DoxyItemize}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & An \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}, which points to the base memory address of I2C registers. \mbox{\hyperlink{_e_f___i2_c__regs_8h_ab0d3f158914422e7299a70fcd51e6141}{EF\+\_\+\+I2\+C\+\_\+\+TYPE}} is a structure that contains the I2C registers. \\
\hline
\mbox{\texttt{ out}}  & {\em ris\+\_\+value} & A pointer to a 32-\/bit variable where the raw interrupt status will be stored.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a69c76d64d9e2e6d29d53026b0fa1055c}\label{_e_f___i2_c_8h_a69c76d64d9e2e6d29d53026b0fa1055c}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_isBusy@{EF\_I2C\_isBusy}}
\index{EF\_I2C\_isBusy@{EF\_I2C\_isBusy}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_isBusy()}{EF\_I2C\_isBusy()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+is\+Busy (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{bool $\ast$}]{is\+\_\+busy }\end{DoxyParamCaption})}



Checks if the I2C peripheral is busy. 

! Sets the Interrupt Clear (ICR) register. $\ast$!

This function checks the {\ttfamily STATUS} register of the I2C peripheral to determine if the bus is currently busy. The result is stored in the memory location pointed to by {\ttfamily is\+\_\+busy}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ out}}  & {\em is\+\_\+busy} & Pointer to a boolean where the busy status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: I2C is busy.
\item {\ttfamily false}\+: I2C is idle.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type EF\+\_\+\+DRIVER\+\_\+\+STATUS\+:
\begin{DoxyItemize}
\item EF\+\_\+\+DRIVER\+\_\+\+OK\+: The operation completed successfully.
\item EF\+\_\+\+DRIVER\+\_\+\+ERROR\+\_\+\+PARAMETER\+: {\ttfamily i2c} or {\ttfamily is\+\_\+busy} is NULL. 
\end{DoxyItemize}
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a14e5de684a330a987584ba5219bf8304}\label{_e_f___i2_c_8h_a14e5de684a330a987584ba5219bf8304}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_isCommandFIFOAvailable@{EF\_I2C\_isCommandFIFOAvailable}}
\index{EF\_I2C\_isCommandFIFOAvailable@{EF\_I2C\_isCommandFIFOAvailable}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_isCommandFIFOAvailable()}{EF\_I2C\_isCommandFIFOAvailable()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+is\+Command\+FIFOAvailable (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{bool $\ast$}]{is\+\_\+available }\end{DoxyParamCaption})}



Checks if the command FIFO is available. 

This function checks the {\ttfamily STATUS} register of the I2C peripheral to determine if the command FIFO is not full and ready to accept new commands. The result is stored in the memory location pointed to by {\ttfamily is\+\_\+available}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ out}}  & {\em is\+\_\+available} & Pointer to a boolean where the availability status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: Command FIFO is available.
\item {\ttfamily false}\+: Command FIFO is full.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a463bfb817bed4b5d06308211df98c7b4}\label{_e_f___i2_c_8h_a463bfb817bed4b5d06308211df98c7b4}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_isReadFIFOAvailable@{EF\_I2C\_isReadFIFOAvailable}}
\index{EF\_I2C\_isReadFIFOAvailable@{EF\_I2C\_isReadFIFOAvailable}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_isReadFIFOAvailable()}{EF\_I2C\_isReadFIFOAvailable()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+is\+Read\+FIFOAvailable (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{bool $\ast$}]{is\+\_\+available }\end{DoxyParamCaption})}



Checks if the read FIFO is available. 

This function checks the {\ttfamily STATUS} register of the I2C peripheral to determine if the read FIFO is not empty and has data available to be read. The result is stored in the memory location pointed to by {\ttfamily is\+\_\+available}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ out}}  & {\em is\+\_\+available} & Pointer to a boolean where the availability status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: Read FIFO is available.
\item {\ttfamily false}\+: Read FIFO is empty.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_aba9df55dc50dffa193d8990d9d3354b3}\label{_e_f___i2_c_8h_aba9df55dc50dffa193d8990d9d3354b3}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_isWriteFIFOAvailable@{EF\_I2C\_isWriteFIFOAvailable}}
\index{EF\_I2C\_isWriteFIFOAvailable@{EF\_I2C\_isWriteFIFOAvailable}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_isWriteFIFOAvailable()}{EF\_I2C\_isWriteFIFOAvailable()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+is\+Write\+FIFOAvailable (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{bool $\ast$}]{is\+\_\+available }\end{DoxyParamCaption})}



Checks if the write FIFO is available. 

This function checks the {\ttfamily STATUS} register of the I2C peripheral to determine if the write FIFO is not full and ready to accept new data. The result is stored in the memory location pointed to by {\ttfamily is\+\_\+available}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ out}}  & {\em is\+\_\+available} & Pointer to a boolean where the availability status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: Write FIFO is available.
\item {\ttfamily false}\+: Write FIFO is full.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a1d9931eb963c13f5bbc96e2ba3c5bdab}\label{_e_f___i2_c_8h_a1d9931eb963c13f5bbc96e2ba3c5bdab}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_readDataFromReadFIFO@{EF\_I2C\_readDataFromReadFIFO}}
\index{EF\_I2C\_readDataFromReadFIFO@{EF\_I2C\_readDataFromReadFIFO}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_readDataFromReadFIFO()}{EF\_I2C\_readDataFromReadFIFO()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+read\+Data\+From\+Read\+FIFO (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint8\+\_\+t $\ast$}]{data }\end{DoxyParamCaption})}



Reads data from the I2C Read FIFO (blocking). 

This function reads a single byte of data from the I2C Read FIFO. It blocks until the FIFO becomes available and validates the data read.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ out}}  & {\em data} & Pointer to a variable where the read data byte will be stored.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type EF\+\_\+\+DRIVER\+\_\+\+STATUS\+:
\begin{DoxyItemize}
\item EF\+\_\+\+DRIVER\+\_\+\+OK\+: The operation completed successfully.
\item EF\+\_\+\+DRIVER\+\_\+\+ERROR\+\_\+\+PARAMETER\+: {\ttfamily i2c} or {\ttfamily data} is NULL.
\item EF\+\_\+\+DRIVER\+\_\+\+ERROR\+\_\+\+I2\+C\+\_\+\+INVALID\+\_\+\+DATA\+: The data read is invalid. 
\end{DoxyItemize}
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_abc156cb4e2acec2cc205775b7ce3fccd}\label{_e_f___i2_c_8h_abc156cb4e2acec2cc205775b7ce3fccd}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_readDataFromReadFIFONonBlocking@{EF\_I2C\_readDataFromReadFIFONonBlocking}}
\index{EF\_I2C\_readDataFromReadFIFONonBlocking@{EF\_I2C\_readDataFromReadFIFONonBlocking}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_readDataFromReadFIFONonBlocking()}{EF\_I2C\_readDataFromReadFIFONonBlocking()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+read\+Data\+From\+Read\+FIFONon\+Blocking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint8\+\_\+t $\ast$}]{data,  }\item[{bool $\ast$}]{data\+\_\+read }\end{DoxyParamCaption})}



Reads data from the I2C Read FIFO (non-\/blocking). 

This function attempts to read a single byte of data from the I2C Read FIFO. If the FIFO is unavailable, the function returns immediately. The validity of the data is also checked.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ out}}  & {\em data} & Pointer to a variable where the read data byte will be stored. \\
\hline
\mbox{\texttt{ out}}  & {\em data\+\_\+read} & Pointer to a boolean where the read status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: Data was read successfully and is valid.
\item {\ttfamily false}\+: Read FIFO was unavailable or data is invalid.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type EF\+\_\+\+DRIVER\+\_\+\+STATUS\+:
\begin{DoxyItemize}
\item EF\+\_\+\+DRIVER\+\_\+\+OK\+: The operation completed successfully.
\item EF\+\_\+\+DRIVER\+\_\+\+ERROR\+\_\+\+PARAMETER\+: {\ttfamily i2c}, {\ttfamily data}, or {\ttfamily data\+\_\+read} is NULL.
\item EF\+\_\+\+DRIVER\+\_\+\+ERROR\+\_\+\+I2\+C\+\_\+\+INVALID\+\_\+\+DATA\+: The data read is invalid. 
\end{DoxyItemize}
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a0689bd62e532fda19ee62cd4b45b65c5}\label{_e_f___i2_c_8h_a0689bd62e532fda19ee62cd4b45b65c5}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_receiveByte@{EF\_I2C\_receiveByte}}
\index{EF\_I2C\_receiveByte@{EF\_I2C\_receiveByte}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_receiveByte()}{EF\_I2C\_receiveByte()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+receive\+Byte (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint8\+\_\+t $\ast$}]{data,  }\item[{uint8\+\_\+t}]{addr }\end{DoxyParamCaption})}



Receives a single byte from a specified I2C address (blocking). 

This function reads a single byte from a specified I2C address. It blocks until all operations (read command, stop command, and data retrieval) are completed.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ out}}  & {\em data} & Pointer to a uint8\+\_\+t where the received data byte will be stored. \\
\hline
\mbox{\texttt{ in}}  & {\em addr} & I2C address from which the data will be read.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a13b810bd29c715c8698c77e8991d5913}\label{_e_f___i2_c_8h_a13b810bd29c715c8698c77e8991d5913}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_receiveByteNonBlocking@{EF\_I2C\_receiveByteNonBlocking}}
\index{EF\_I2C\_receiveByteNonBlocking@{EF\_I2C\_receiveByteNonBlocking}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_receiveByteNonBlocking()}{EF\_I2C\_receiveByteNonBlocking()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+receive\+Byte\+Non\+Blocking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint8\+\_\+t $\ast$}]{data,  }\item[{uint8\+\_\+t}]{addr,  }\item[{bool $\ast$}]{received }\end{DoxyParamCaption})}



Receives a single byte from a specified I2C address (non-\/blocking). 

This function attempts to read a single byte from a specified I2C address in a non-\/blocking manner. If any step of the process (read command, stop command, or data retrieval) cannot complete immediately, the function returns.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ out}}  & {\em data} & Pointer to a uint8\+\_\+t where the received data byte will be stored. \\
\hline
\mbox{\texttt{ in}}  & {\em addr} & I2C address from which the data will be read. \\
\hline
\mbox{\texttt{ out}}  & {\em received} & Pointer to a boolean where the reception status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: Data was received successfully.
\item {\ttfamily false}\+: Reception could not be completed.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a82de40473f83b733860a491e825bfa2c}\label{_e_f___i2_c_8h_a82de40473f83b733860a491e825bfa2c}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_recieveCharArr@{EF\_I2C\_recieveCharArr}}
\index{EF\_I2C\_recieveCharArr@{EF\_I2C\_recieveCharArr}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_recieveCharArr()}{EF\_I2C\_recieveCharArr()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+recieve\+Char\+Arr (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint8\+\_\+t $\ast$}]{data,  }\item[{uint32\+\_\+t}]{data\+\_\+length,  }\item[{uint8\+\_\+t}]{addr }\end{DoxyParamCaption})}



Receives an array of bytes from a specified I2C address (blocking). 

This function reads an array of bytes from a specified I2C address. It issues the read command for each byte, stores the data in the provided buffer, and sends a stop command after successful reception.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ out}}  & {\em data} & Pointer to the buffer where the received bytes will be stored. \\
\hline
\mbox{\texttt{ in}}  & {\em data\+\_\+length} & Number of bytes to receive. \\
\hline
\mbox{\texttt{ in}}  & {\em addr} & I2C address from which the data will be read.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a5a4eefaa77952dce9da7af76b06e8d90}\label{_e_f___i2_c_8h_a5a4eefaa77952dce9da7af76b06e8d90}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_sendReadCommand@{EF\_I2C\_sendReadCommand}}
\index{EF\_I2C\_sendReadCommand@{EF\_I2C\_sendReadCommand}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_sendReadCommand()}{EF\_I2C\_sendReadCommand()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+send\+Read\+Command (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint8\+\_\+t}]{addr }\end{DoxyParamCaption})}



Sends a read command to the I2C device (blocking). 

This function sends a read command to the I2C device at the specified address. It blocks until the command FIFO becomes available.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ in}}  & {\em addr} & The I2C address of the target device.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_ad761e01240a00cd0a0163838aa52fbf3}\label{_e_f___i2_c_8h_ad761e01240a00cd0a0163838aa52fbf3}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_sendReadCommandNonBlocking@{EF\_I2C\_sendReadCommandNonBlocking}}
\index{EF\_I2C\_sendReadCommandNonBlocking@{EF\_I2C\_sendReadCommandNonBlocking}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_sendReadCommandNonBlocking()}{EF\_I2C\_sendReadCommandNonBlocking()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+send\+Read\+Command\+Non\+Blocking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint8\+\_\+t}]{addr,  }\item[{bool $\ast$}]{command\+\_\+sent }\end{DoxyParamCaption})}



Sends a read command to the I2C device (non-\/blocking). 

This function attempts to send a read command to the I2C device at the specified address. If the command FIFO is unavailable, the function returns immediately.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ in}}  & {\em addr} & The I2C address of the target device. \\
\hline
\mbox{\texttt{ out}}  & {\em command\+\_\+sent} & Pointer to a boolean where the command status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: Command was sent successfully.
\item {\ttfamily false}\+: Command FIFO was unavailable.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_ad1fa3cec145bfbd8027e0370137c1b9d}\label{_e_f___i2_c_8h_ad1fa3cec145bfbd8027e0370137c1b9d}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_sendStartCommand@{EF\_I2C\_sendStartCommand}}
\index{EF\_I2C\_sendStartCommand@{EF\_I2C\_sendStartCommand}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_sendStartCommand()}{EF\_I2C\_sendStartCommand()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+send\+Start\+Command (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c }\end{DoxyParamCaption})}



Sends a start condition on the I2C bus (blocking). 

This function sends a start condition on the I2C bus. It blocks until the command FIFO becomes available.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a5895919e916705ee1082efade9f1488e}\label{_e_f___i2_c_8h_a5895919e916705ee1082efade9f1488e}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_sendStartCommandNonBlocking@{EF\_I2C\_sendStartCommandNonBlocking}}
\index{EF\_I2C\_sendStartCommandNonBlocking@{EF\_I2C\_sendStartCommandNonBlocking}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_sendStartCommandNonBlocking()}{EF\_I2C\_sendStartCommandNonBlocking()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+send\+Start\+Command\+Non\+Blocking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{bool $\ast$}]{command\+\_\+sent }\end{DoxyParamCaption})}



Sends a start condition on the I2C bus (non-\/blocking). 

This function attempts to send a start condition on the I2C bus. If the command FIFO is unavailable, the function returns immediately.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ out}}  & {\em command\+\_\+sent} & Pointer to a boolean where the command status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: Start condition was sent successfully.
\item {\ttfamily false}\+: Command FIFO was unavailable.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a4545f7e33e2e35e7b100b6f3857433bd}\label{_e_f___i2_c_8h_a4545f7e33e2e35e7b100b6f3857433bd}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_sendStopCommand@{EF\_I2C\_sendStopCommand}}
\index{EF\_I2C\_sendStopCommand@{EF\_I2C\_sendStopCommand}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_sendStopCommand()}{EF\_I2C\_sendStopCommand()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+send\+Stop\+Command (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c }\end{DoxyParamCaption})}



Sends a stop condition on the I2C bus (blocking). 

This function sends a stop condition on the I2C bus. It blocks until the command FIFO becomes available.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_adc35bddf018b22d9f822442360d9a1e5}\label{_e_f___i2_c_8h_adc35bddf018b22d9f822442360d9a1e5}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_sendStopCommandNonBlocking@{EF\_I2C\_sendStopCommandNonBlocking}}
\index{EF\_I2C\_sendStopCommandNonBlocking@{EF\_I2C\_sendStopCommandNonBlocking}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_sendStopCommandNonBlocking()}{EF\_I2C\_sendStopCommandNonBlocking()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+send\+Stop\+Command\+Non\+Blocking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{bool $\ast$}]{command\+\_\+sent }\end{DoxyParamCaption})}



Sends a stop condition on the I2C bus (non-\/blocking). 

This function attempts to send a stop condition on the I2C bus. If the command FIFO is unavailable, the function returns immediately.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ out}}  & {\em command\+\_\+sent} & Pointer to a boolean where the command status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: Stop condition was sent successfully.
\item {\ttfamily false}\+: Command FIFO was unavailable.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a374bdcd7a2d9994dd762b93260e7e988}\label{_e_f___i2_c_8h_a374bdcd7a2d9994dd762b93260e7e988}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_sendWriteCommand@{EF\_I2C\_sendWriteCommand}}
\index{EF\_I2C\_sendWriteCommand@{EF\_I2C\_sendWriteCommand}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_sendWriteCommand()}{EF\_I2C\_sendWriteCommand()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+send\+Write\+Command (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint8\+\_\+t}]{addr }\end{DoxyParamCaption})}



Sends a write command to the I2C device (blocking). 

This function sends a write command to the I2C device at the specified address. It blocks until the command FIFO becomes available.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ in}}  & {\em addr} & The I2C address of the target device.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a1ca44050fd31a0970d9a843ce2b660b7}\label{_e_f___i2_c_8h_a1ca44050fd31a0970d9a843ce2b660b7}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_sendWriteCommandNonBlocking@{EF\_I2C\_sendWriteCommandNonBlocking}}
\index{EF\_I2C\_sendWriteCommandNonBlocking@{EF\_I2C\_sendWriteCommandNonBlocking}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_sendWriteCommandNonBlocking()}{EF\_I2C\_sendWriteCommandNonBlocking()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+send\+Write\+Command\+Non\+Blocking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint8\+\_\+t}]{addr,  }\item[{bool $\ast$}]{command\+\_\+sent }\end{DoxyParamCaption})}



Sends a write command to the I2C device (non-\/blocking). 

This function attempts to send a write command to the I2C device at the specified address. If the command FIFO is unavailable, the function returns immediately.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ in}}  & {\em addr} & The I2C address of the target device. \\
\hline
\mbox{\texttt{ out}}  & {\em command\+\_\+sent} & Pointer to a boolean where the command status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: Command was sent successfully.
\item {\ttfamily false}\+: Command FIFO was unavailable.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_acfba97829c658e87ce338d95ab35cd6a}\label{_e_f___i2_c_8h_acfba97829c658e87ce338d95ab35cd6a}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_sendWriteMultipleCommand@{EF\_I2C\_sendWriteMultipleCommand}}
\index{EF\_I2C\_sendWriteMultipleCommand@{EF\_I2C\_sendWriteMultipleCommand}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_sendWriteMultipleCommand()}{EF\_I2C\_sendWriteMultipleCommand()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+send\+Write\+Multiple\+Command (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint8\+\_\+t}]{addr }\end{DoxyParamCaption})}



Sends a \char`\"{}write multiple\char`\"{} command on the I2C bus (blocking). 

This function sends a \char`\"{}write multiple\char`\"{} command on the I2C bus. It blocks until the command FIFO becomes available.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a4e0baaf0ed013abb939201fe71e179ae}\label{_e_f___i2_c_8h_a4e0baaf0ed013abb939201fe71e179ae}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_sendWriteMultipleCommandNonBlocking@{EF\_I2C\_sendWriteMultipleCommandNonBlocking}}
\index{EF\_I2C\_sendWriteMultipleCommandNonBlocking@{EF\_I2C\_sendWriteMultipleCommandNonBlocking}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_sendWriteMultipleCommandNonBlocking()}{EF\_I2C\_sendWriteMultipleCommandNonBlocking()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+send\+Write\+Multiple\+Command\+Non\+Blocking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint8\+\_\+t}]{addr,  }\item[{bool $\ast$}]{command\+\_\+sent }\end{DoxyParamCaption})}



Sends a \char`\"{}write multiple\char`\"{} command on the I2C bus (non-\/blocking). 

This function attempts to send a \char`\"{}write multiple\char`\"{} command on the I2C bus. If the command FIFO is unavailable, the function returns immediately.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ out}}  & {\em command\+\_\+sent} & Pointer to a boolean where the command status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: The \char`\"{}write multiple\char`\"{} command was sent successfully.
\item {\ttfamily false}\+: Command FIFO was unavailable.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a2286c60de589dcecb0fc78a48187440b}\label{_e_f___i2_c_8h_a2286c60de589dcecb0fc78a48187440b}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_setCommandReg@{EF\_I2C\_setCommandReg}}
\index{EF\_I2C\_setCommandReg@{EF\_I2C\_setCommandReg}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_setCommandReg()}{EF\_I2C\_setCommandReg()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+set\+Command\+Reg (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint32\+\_\+t}]{value }\end{DoxyParamCaption})}



Sets the command register of the I2C controller. 

This ia a blocking function that writes a specified value directly to the I2C command register. It allows manual configuration of the I2C controller for advanced or custom operations.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & An \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}, which points to the base memory address of I2C registers. \mbox{\hyperlink{_e_f___i2_c__regs_8h_ab0d3f158914422e7299a70fcd51e6141}{EF\+\_\+\+I2\+C\+\_\+\+TYPE}} is a structure that contains the I2C registers. \\
\hline
\mbox{\texttt{ in}}  & {\em value} & The 32-\/bit value to write to the I2C command register. This value typically contains specific bit fields to configure the I2C operation.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_ac5ca754457eaaeeab83e607fd78039e9}\label{_e_f___i2_c_8h_ac5ca754457eaaeeab83e607fd78039e9}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_setCommandRegNonBlocking@{EF\_I2C\_setCommandRegNonBlocking}}
\index{EF\_I2C\_setCommandRegNonBlocking@{EF\_I2C\_setCommandRegNonBlocking}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_setCommandRegNonBlocking()}{EF\_I2C\_setCommandRegNonBlocking()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+set\+Command\+Reg\+Non\+Blocking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint32\+\_\+t}]{value,  }\item[{bool $\ast$}]{command\+\_\+sent }\end{DoxyParamCaption})}



Writes a command value to the I2C command register (non-\/blocking). 

This function attempts to write a specified command value to the I2C command register in a non-\/blocking manner. It checks the availability of the command FIFO before writing and updates the provided flag to indicate success.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ in}}  & {\em value} & The command value to be written to the command register. \\
\hline
\mbox{\texttt{ out}}  & {\em command\+\_\+sent} & Pointer to a boolean flag that indicates whether the command was successfully sent\+:
\begin{DoxyItemize}
\item true\+: Command was written successfully.
\item false\+: Command was not written (FIFO unavailable or error).
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a20ba0e48023589b93dc8fe15519c5482}\label{_e_f___i2_c_8h_a20ba0e48023589b93dc8fe15519c5482}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_setDataLast@{EF\_I2C\_setDataLast}}
\index{EF\_I2C\_setDataLast@{EF\_I2C\_setDataLast}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_setDataLast()}{EF\_I2C\_setDataLast()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+set\+Data\+Last (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c }\end{DoxyParamCaption})}



Sets the data last flag in the I2C data register. 

This function modifies the data last flag in the I2C data register. The flag indicates whether the current data is the last in an I2C transaction.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & An \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}, which points to the base memory address of I2C registers. \mbox{\hyperlink{_e_f___i2_c__regs_8h_ab0d3f158914422e7299a70fcd51e6141}{EF\+\_\+\+I2\+C\+\_\+\+TYPE}} is a structure that contains the I2C registers. \\
\hline
\mbox{\texttt{ in}}  & {\em valid} & A boolean value specifying the state of the data last flag. Set to {\ttfamily true} to mark the data as the last in the transaction, or {\ttfamily false} to clear the flag.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a8cd33e8dde8407bb760d8a9e06548dea}\label{_e_f___i2_c_8h_a8cd33e8dde8407bb760d8a9e06548dea}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_setGclkEnable@{EF\_I2C\_setGclkEnable}}
\index{EF\_I2C\_setGclkEnable@{EF\_I2C\_setGclkEnable}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_setGclkEnable()}{EF\_I2C\_setGclkEnable()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+set\+Gclk\+Enable (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint32\+\_\+t}]{value }\end{DoxyParamCaption})}



Sets the GCLK enable bit in the I2C register to a certain value. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & An \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}} , which points to the base memory address of I2C registers. \mbox{\hyperlink{_e_f___i2_c__regs_8h_ab0d3f158914422e7299a70fcd51e6141}{EF\+\_\+\+I2\+C\+\_\+\+TYPE}} is a structure that contains the I2C registers. \\
\hline
\mbox{\texttt{ in}}  & {\em value} & The value of the GCLK enable bit\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_ac9a53ca41924b84ebf52d2b659c029c7}\label{_e_f___i2_c_8h_ac9a53ca41924b84ebf52d2b659c029c7}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_setIM@{EF\_I2C\_setIM}}
\index{EF\_I2C\_setIM@{EF\_I2C\_setIM}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_setIM()}{EF\_I2C\_setIM()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+set\+IM (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint32\+\_\+t}]{mask }\end{DoxyParamCaption})}



Sets the Interrupt Mask (IM) register. 

This function writes a mask value to the interrupt mask register (IM) of the I2C peripheral. The IM register enables or disables the interrupt sources. The bits set in this register determine which interrupt sources generate masked interrupts. IM Register Breakdown$\ast$$\ast$\+:
\begin{DoxyItemize}
\item Bit 0\+: MISS\+\_\+\+ACK -\/ Slave ACK is missed
\item Bit 1\+: CMDE -\/ Command FIFO is Empty
\item Bit 2\+: CMDF -\/ Command FIFO is Full
\item Bit 3\+: CMDOVF -\/ Command FIFO overflow; write 1 to clear
\item Bit 4\+: WRE -\/ Write FIFO is Empty
\item Bit 5\+: WRF -\/ Write FIFO is Full
\item Bit 6\+: WROVF -\/ Write FIFO overflow; write 1 to clear
\item Bit 7\+: RDE -\/ Read FIFO is Empty
\item Bit 8\+: RDF -\/ Read FIFO is Full
\item Bits \mbox{[}9-\/31\mbox{]}\+: Reserved. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & An \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}, which points to the base memory address of I2C registers. \mbox{\hyperlink{_e_f___i2_c__regs_8h_ab0d3f158914422e7299a70fcd51e6141}{EF\+\_\+\+I2\+C\+\_\+\+TYPE}} is a structure that contains the I2C registers. \\
\hline
\mbox{\texttt{ in}}  & {\em mask} & A 32-\/bit mask value to be written to the IM register. Each bit corresponds to a specific interrupt source, with 1 enabling the interrupt and 0 disabling it.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}

\end{DoxyItemize}\mbox{\Hypertarget{_e_f___i2_c_8h_a824f4aaa04cf1518f65a558c67172fdd}\label{_e_f___i2_c_8h_a824f4aaa04cf1518f65a558c67172fdd}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_setPrescaler@{EF\_I2C\_setPrescaler}}
\index{EF\_I2C\_setPrescaler@{EF\_I2C\_setPrescaler}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_setPrescaler()}{EF\_I2C\_setPrescaler()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+set\+Prescaler (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint32\+\_\+t}]{value }\end{DoxyParamCaption})}



Sets the I2C prescaler value. 

This function sets the prescaler value for the I2C peripheral. The prescaler is used to configure the speed of the I2C communication by adjusting the clock frequency.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & An \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}, which points to the base memory address of I2C registers. \mbox{\hyperlink{_e_f___i2_c__regs_8h_ab0d3f158914422e7299a70fcd51e6141}{EF\+\_\+\+I2\+C\+\_\+\+TYPE}} is a structure that contains the I2C registers. \\
\hline
\mbox{\texttt{ in}}  & {\em value} & The prescaler value to set for the I2C clock. This value determines the clock frequency for I2C communication.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a2b86143755c8196c79b8eeb89299a101}\label{_e_f___i2_c_8h_a2b86143755c8196c79b8eeb89299a101}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_transmitByte@{EF\_I2C\_transmitByte}}
\index{EF\_I2C\_transmitByte@{EF\_I2C\_transmitByte}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_transmitByte()}{EF\_I2C\_transmitByte()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+transmit\+Byte (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint8\+\_\+t}]{data,  }\item[{uint8\+\_\+t}]{addr }\end{DoxyParamCaption})}



Transmits a single byte to a specified I2C address (blocking). 

This function transmits a single byte to a specified I2C address using the Write FIFO. It blocks until all operations (data write, write command, and stop command) are completed.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ in}}  & {\em data} & Data byte to be transmitted. \\
\hline
\mbox{\texttt{ in}}  & {\em addr} & I2C address to which the data will be sent.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a33dc1953f3b3819bf3c2c88191f80b03}\label{_e_f___i2_c_8h_a33dc1953f3b3819bf3c2c88191f80b03}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_transmitByteNonBlocking@{EF\_I2C\_transmitByteNonBlocking}}
\index{EF\_I2C\_transmitByteNonBlocking@{EF\_I2C\_transmitByteNonBlocking}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_transmitByteNonBlocking()}{EF\_I2C\_transmitByteNonBlocking()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+transmit\+Byte\+Non\+Blocking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint8\+\_\+t}]{data,  }\item[{uint8\+\_\+t}]{addr,  }\item[{bool $\ast$}]{transmitted }\end{DoxyParamCaption})}



Transmits a single byte to a specified I2C address (non-\/blocking). 

This function attempts to transmit a single byte to a specified I2C address using the Write FIFO in a non-\/blocking manner. If any step of the process (data write, write command, or stop command) cannot complete immediately, the function returns.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ in}}  & {\em data} & Data byte to be transmitted. \\
\hline
\mbox{\texttt{ in}}  & {\em addr} & I2C address to which the data will be sent. \\
\hline
\mbox{\texttt{ out}}  & {\em transmitted} & Pointer to a boolean where the transmission status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: Data was transmitted successfully.
\item {\ttfamily false}\+: Transmission could not be completed.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_aee77f1eec83d3dd4b709eeedc9ede05d}\label{_e_f___i2_c_8h_aee77f1eec83d3dd4b709eeedc9ede05d}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_transmitCharArr@{EF\_I2C\_transmitCharArr}}
\index{EF\_I2C\_transmitCharArr@{EF\_I2C\_transmitCharArr}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_transmitCharArr()}{EF\_I2C\_transmitCharArr()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+transmit\+Char\+Arr (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint8\+\_\+t $\ast$}]{data,  }\item[{uint32\+\_\+t}]{data\+\_\+length,  }\item[{uint8\+\_\+t}]{addr }\end{DoxyParamCaption})}



Transmits an array of bytes to a specified I2C address (blocking). 

This function sends an array of bytes to a specified I2C address. It handles writing the data to the I2C FIFO and ensures the last byte is appropriately marked.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ in}}  & {\em data} & Pointer to the array of bytes to be transmitted. \\
\hline
\mbox{\texttt{ in}}  & {\em data\+\_\+length} & Number of bytes in the array to transmit. \\
\hline
\mbox{\texttt{ in}}  & {\em addr} & I2C address to which the data will be sent.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a2145a943f79505d4c057bc6958d034eb}\label{_e_f___i2_c_8h_a2145a943f79505d4c057bc6958d034eb}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_writeDataToWriteFIFO@{EF\_I2C\_writeDataToWriteFIFO}}
\index{EF\_I2C\_writeDataToWriteFIFO@{EF\_I2C\_writeDataToWriteFIFO}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_writeDataToWriteFIFO()}{EF\_I2C\_writeDataToWriteFIFO()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+write\+Data\+To\+Write\+FIFO (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint8\+\_\+t}]{data }\end{DoxyParamCaption})}



Writes data to the I2C Write FIFO (blocking). 

This function writes a single byte of data to the I2C Write FIFO. It blocks until the FIFO becomes available.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ in}}  & {\em data} & Data byte to be written to the FIFO.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
\mbox{\Hypertarget{_e_f___i2_c_8h_a9cf8cd0c4282ed5cc45954c6de74cae8}\label{_e_f___i2_c_8h_a9cf8cd0c4282ed5cc45954c6de74cae8}} 
\index{EF\_I2C.h@{EF\_I2C.h}!EF\_I2C\_writeDataToWriteFIFONonBlocking@{EF\_I2C\_writeDataToWriteFIFONonBlocking}}
\index{EF\_I2C\_writeDataToWriteFIFONonBlocking@{EF\_I2C\_writeDataToWriteFIFONonBlocking}!EF\_I2C.h@{EF\_I2C.h}}
\doxysubsubsection{\texorpdfstring{EF\_I2C\_writeDataToWriteFIFONonBlocking()}{EF\_I2C\_writeDataToWriteFIFONonBlocking()}}
{\footnotesize\ttfamily \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} EF\+\_\+\+I2\+C\+\_\+write\+Data\+To\+Write\+FIFONon\+Blocking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}}]{i2c,  }\item[{uint8\+\_\+t}]{data,  }\item[{bool $\ast$}]{data\+\_\+written }\end{DoxyParamCaption})}



Writes data to the I2C Write FIFO (non-\/blocking). 

This function attempts to write a single byte of data to the I2C Write FIFO. If the FIFO is unavailable, the function returns immediately.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em i2c} & Pointer to the I2C base address structure \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR}}. \\
\hline
\mbox{\texttt{ in}}  & {\em data} & Data byte to be written to the FIFO. \\
\hline
\mbox{\texttt{ out}}  & {\em data\+\_\+written} & Pointer to a boolean where the write status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: The data was written successfully.
\item {\ttfamily false}\+: Write FIFO was unavailable.
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status A value of type \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\+\_\+\+DRIVER\+\_\+\+STATUS}} \+: returns a success or error code 
\end{DoxyReturn}
