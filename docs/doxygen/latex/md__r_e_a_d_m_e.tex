\hypertarget{md__r_e_a_d_m_e_autotoc_md1}{}\doxysection{Header files}\label{md__r_e_a_d_m_e_autotoc_md1}

\begin{DoxyItemize}
\item EF\+\_\+\+Driver\+\_\+\+Common.h
\item EF\+\_\+\+I2C.h
\item EF\+\_\+\+I2\+C\+\_\+regs.h
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md2}{}\doxysection{File EF\+\_\+\+Driver\+\_\+\+Common.\+h}\label{md__r_e_a_d_m_e_autotoc_md2}
{\itshape C header file for common driver definitions and types.}\hypertarget{md__r_e_a_d_m_e_autotoc_md3}{}\doxysection{Structures and Types}\label{md__r_e_a_d_m_e_autotoc_md3}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\raggedleft \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\cellcolor{\tableheadbgcolor}\textbf{ Name    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\raggedleft \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\cellcolor{\tableheadbgcolor}\textbf{ Name    }\\\cline{1-2}
\endhead
\PBS\raggedleft typedef uint32\+\_\+t   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ ~\newline
{\itshape A type that is used to return the status of the driver functions.}   \\\cline{1-2}
\end{longtabu}
\hypertarget{md__r_e_a_d_m_e_autotoc_md4}{}\doxysection{Macros}\label{md__r_e_a_d_m_e_autotoc_md4}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\raggedleft \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\cellcolor{\tableheadbgcolor}\textbf{ Name    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\raggedleft \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\cellcolor{\tableheadbgcolor}\textbf{ Name    }\\\cline{1-2}
\endhead
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+ERROR$\ast$$\ast$ ((uint32\+\_\+t)1)~\newline
{\itshape Unspecified error.}    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+ERROR\textbackslash{}\+\_\+\+BUSY$\ast$$\ast$ ((uint32\+\_\+t)2)~\newline
{\itshape Driver is busy.}    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+ERROR\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+INVALID\textbackslash{}\+\_\+\+DATA$\ast$$\ast$ ((uint32\+\_\+t)7)~\newline
{\itshape Invalid I2C data.}    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+ERROR\textbackslash{}\+\_\+\+PARAMETER$\ast$$\ast$ ((uint32\+\_\+t)5)~\newline
{\itshape Parameter error.}    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+ERROR\textbackslash{}\+\_\+\+SPECIFIC$\ast$$\ast$ ((uint32\+\_\+t)6)~\newline
{\itshape Start of driver specific errors.}    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+ERROR\textbackslash{}\+\_\+\+TIMEOUT$\ast$$\ast$ ((uint32\+\_\+t)3)~\newline
{\itshape Timeout occurred.}    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+ERROR\textbackslash{}\+\_\+\+UNSUPPORTED$\ast$$\ast$ ((uint32\+\_\+t)4)~\newline
{\itshape Operation not supported.}    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+OK$\ast$$\ast$ ((uint32\+\_\+t)0)~\newline
{\itshape Operation succeeded.}   \\\cline{1-2}
\end{longtabu}
\hypertarget{md__r_e_a_d_m_e_autotoc_md5}{}\doxysection{Structures and Types Documentation}\label{md__r_e_a_d_m_e_autotoc_md5}
\hypertarget{md__r_e_a_d_m_e_autotoc_md6}{}\doxysubsection{typedef $<$tt$>$\+EF\+\_\+\+DRIVER\+\_\+\+STATUS$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md6}
{\itshape A type that is used to return the status of the driver functions.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef}\ uint32\_t\ \mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}};}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md7}{}\doxysection{Macros Documentation}\label{md__r_e_a_d_m_e_autotoc_md7}
\hypertarget{md__r_e_a_d_m_e_autotoc_md8}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+DRIVER\+\_\+\+ERROR$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md8}
{\itshape Unspecified error.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_DRIVER\_ERROR\ ((uint32\_t)1)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md9}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+DRIVER\+\_\+\+ERROR\+\_\+\+BUSY$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md9}
{\itshape Driver is busy.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_DRIVER\_ERROR\_BUSY\ ((uint32\_t)2)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md10}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+DRIVER\+\_\+\+ERROR\+\_\+\+I2\+C\+\_\+\+INVALID\+\_\+\+DATA$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md10}
{\itshape Invalid I2C data.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_DRIVER\_ERROR\_I2C\_INVALID\_DATA\ ((uint32\_t)7)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md11}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+DRIVER\+\_\+\+ERROR\+\_\+\+PARAMETER$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md11}
{\itshape Parameter error.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_DRIVER\_ERROR\_PARAMETER\ ((uint32\_t)5)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md12}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+DRIVER\+\_\+\+ERROR\+\_\+\+SPECIFIC$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md12}
{\itshape Start of driver specific errors.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_DRIVER\_ERROR\_SPECIFIC\ ((uint32\_t)6)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md13}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+DRIVER\+\_\+\+ERROR\+\_\+\+TIMEOUT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md13}
{\itshape Timeout occurred.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_DRIVER\_ERROR\_TIMEOUT\ ((uint32\_t)3)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md14}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+DRIVER\+\_\+\+ERROR\+\_\+\+UNSUPPORTED$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md14}
{\itshape Operation not supported.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_DRIVER\_ERROR\_UNSUPPORTED\ ((uint32\_t)4)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md15}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+DRIVER\+\_\+\+OK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md15}
{\itshape Operation succeeded.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_DRIVER\_OK\ ((uint32\_t)0)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md16}{}\doxysection{File EF\+\_\+\+I2\+C.\+h}\label{md__r_e_a_d_m_e_autotoc_md16}
{\itshape C header file for I2C APIs which contains the function prototypes.}\hypertarget{md__r_e_a_d_m_e_autotoc_md17}{}\doxysection{Functions}\label{md__r_e_a_d_m_e_autotoc_md17}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\raggedleft \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\cellcolor{\tableheadbgcolor}\textbf{ Name    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\raggedleft \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\cellcolor{\tableheadbgcolor}\textbf{ Name    }\\\cline{1-2}
\endhead
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+get\+Data\+Last$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, bool $\ast$data\+\_\+last) ~\newline
{\itshape Reads the data last flag from the I2C data register.}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+get\+Data\+Valid$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, bool $\ast$data\+\_\+valid) ~\newline
{\itshape Reads the data valid flag from the I2C data register.}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+get\+IM$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, uint32\+\_\+t $\ast$im\+\_\+value) ~\newline
{\itshape Reads the Interrupt Mask (IM) register.}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+get\+MIS$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, uint32\+\_\+t $\ast$mis\+\_\+value) ~\newline
{\itshape Reads the Masked Interrupt Status (MIS) register.}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+get\+Prescaler$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, uint32\+\_\+t $\ast$prescaler\+\_\+value) ~\newline
{\itshape Gets the I2C prescaler value.}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+get\+RIS$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, uint32\+\_\+t $\ast$ris\+\_\+value) ~\newline
{\itshape Reads the Raw Interrupt Status (RIS) register.}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+is\+Busy$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, bool $\ast$is\+\_\+busy) ~\newline
{\itshape Checks if the I2C peripheral is busy.}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+is\+Command\+FIFOAvailable$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, bool $\ast$is\+\_\+available) ~\newline
{\itshape Checks if the command FIFO is available.}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+is\+Read\+FIFOAvailable$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, bool $\ast$is\+\_\+available) ~\newline
{\itshape Checks if the read FIFO is available.}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+is\+Write\+FIFOAvailable$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, bool $\ast$is\+\_\+available) ~\newline
{\itshape Checks if the write FIFO is available.}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+read\+Data\+From\+Read\+FIFO$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, char $\ast$data) ~\newline
{\itshape Reads data from the I2C Read FIFO (blocking).}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+read\+Data\+From\+Read\+FIFONon\+Blocking$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, char $\ast$data, bool $\ast$data\+\_\+read) ~\newline
{\itshape Reads data from the I2C Read FIFO (non-\/blocking).}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+receive\+Byte$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, char $\ast$data, char addr) ~\newline
{\itshape Receives a single byte from a specified I2C address (blocking).}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+receive\+Byte\+Non\+Blocking$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, char $\ast$data, char addr, bool $\ast$received) ~\newline
{\itshape Receives a single byte from a specified I2C address (non-\/blocking).}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+recieve\+Char\+Arr$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, char $\ast$data, uint32\+\_\+t data\+\_\+length, char addr) ~\newline
{\itshape Receives an array of characters from a specified I2C address (blocking).}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+send\+Read\+Command$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, char addr) ~\newline
{\itshape Sends a read command to the I2C device (blocking).}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+send\+Read\+Command\+Non\+Blocking$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, char addr, bool $\ast$command\+\_\+sent) ~\newline
{\itshape Sends a read command to the I2C device (non-\/blocking).}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+send\+Start\+Command$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c) ~\newline
{\itshape Sends a start condition on the I2C bus (blocking).}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+send\+Start\+Command\+Non\+Blocking$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, bool $\ast$command\+\_\+sent) ~\newline
{\itshape Sends a start condition on the I2C bus (non-\/blocking).}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+send\+Stop\+Command$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c) ~\newline
{\itshape Sends a stop condition on the I2C bus (blocking).}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+send\+Stop\+Command\+Non\+Blocking$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, bool $\ast$command\+\_\+sent) ~\newline
{\itshape Sends a stop condition on the I2C bus (non-\/blocking).}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+send\+Write\+Command$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, char addr) ~\newline
{\itshape Sends a write command to the I2C device (blocking).}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+send\+Write\+Command\+Non\+Blocking$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, char addr, bool $\ast$command\+\_\+sent) ~\newline
{\itshape Sends a write command to the I2C device (non-\/blocking).}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+send\+Write\+Multiple\+Command$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c) ~\newline
{\itshape Sends a \char`\"{}write multiple\char`\"{} command on the I2C bus (blocking).}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+send\+Write\+Multiple\+Command\+Non\+Blocking$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, bool $\ast$command\+\_\+sent) ~\newline
{\itshape Sends a \char`\"{}write multiple\char`\"{} command on the I2C bus (non-\/blocking).}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+set\+Command\+Reg$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, uint32\+\_\+t value) ~\newline
{\itshape Sets the command register of the I2C controller.}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+set\+Command\+Reg\+Non\+Blocking$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, uint32\+\_\+t value, bool $\ast$command\+\_\+sent) ~\newline
{\itshape Writes a command value to the I2C command register (non-\/blocking).}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+set\+Data\+Last$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c) ~\newline
{\itshape Sets the data last flag in the I2C data register.}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+set\+Gclk\+Enable$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, uint32\+\_\+t value) ~\newline
{\itshape Sets the GCLK enable bit in the I2C register to a certain value.}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+set\+IM$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, uint32\+\_\+t mask) ~\newline
{\itshape Sets the Interrupt Mask (IM) register.}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+set\+Prescaler$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, uint32\+\_\+t value) ~\newline
{\itshape Sets the I2C prescaler value.}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+transmit\+Byte$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, char data, char addr) ~\newline
{\itshape Transmits a single byte to a specified I2C address (blocking).}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+transmit\+Byte\+Non\+Blocking$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, char data, char addr, bool $\ast$transmitted) ~\newline
{\itshape Transmits a single byte to a specified I2C address (non-\/blocking).}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+transmit\+Char\+Arr$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, char $\ast$data, uint32\+\_\+t data\+\_\+length, char addr) ~\newline
{\itshape Transmits an array of characters to a specified I2C address (blocking).}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+write\+Data\+To\+Write\+FIFO$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, char data) ~\newline
{\itshape Writes data to the I2C Write FIFO (blocking).}    \\\cline{1-2}
\PBS\raggedleft $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+write\+Data\+To\+Write\+FIFONon\+Blocking$\ast$$\ast$ ($\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ i2c, char data, bool $\ast$data\+\_\+written) ~\newline
{\itshape Writes data to the I2C Write FIFO (non-\/blocking).}   \\\cline{1-2}
\end{longtabu}
\hypertarget{md__r_e_a_d_m_e_autotoc_md18}{}\doxysection{Functions Documentation}\label{md__r_e_a_d_m_e_autotoc_md18}
\hypertarget{md__r_e_a_d_m_e_autotoc_md19}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+get\+Data\+Last$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md19}
{\itshape Reads the data last flag from the I2C data register.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a95c96062892f3d3061365eb5d6f83dfe}{EF\_I2C\_getDataLast}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ *data\_last}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function retrieves the current state of the data last flag in the I2C data register. The flag indicates whether the current data is the last in an I2C transaction.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} An $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$, which points to the base memory address of I2C registers.$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE$\ast$$\ast$ is a structure that contains the I2C registers.
\item {\ttfamily data\+\_\+last} A pointer to a boolean variable where the state of the data last flag will be stored. The value is set to {\ttfamily true} if the data is the last in the transaction, or{\ttfamily false} otherwise.
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md20}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+get\+Data\+Valid$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md20}
{\itshape Reads the data valid flag from the I2C data register.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a97ff9205de09e49d12dc62eb1acdcf62}{EF\_I2C\_getDataValid}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ *data\_valid}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function retrieves the current state of the data valid flag in the I2C data register. The flag indicates whether the data is valid for an I2C transaction.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} An $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$, which points to the base memory address of I2C registers.$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE$\ast$$\ast$ is a structure that contains the I2C registers.
\item {\ttfamily data\+\_\+valid} A pointer to a boolean variable where the state of the data valid flag will be stored. The value is set to {\ttfamily true} if the data is valid, or{\ttfamily false} otherwise.
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md21}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+get\+IM$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md21}
{\itshape Reads the Interrupt Mask (IM) register.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_ac4509f632d8b0b1157ec42828a957600}{EF\_I2C\_getIM}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ uint32\_t\ *im\_value}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function reads the interrupt mask register (IM) of the I2C peripheral. The IM register contains a mask value that determines which interrupt sources are enabled. It shows the status of interrupt enablement for various interrupt sources. IM Register Breakdown$\ast$$\ast$\+:


\begin{DoxyItemize}
\item Bit 0\+: MISS\+\_\+\+ACK -\/ Slave ACK is missed
\item Bit 1\+: CMDE -\/ Command FIFO is Empty
\item Bit 2\+: CMDF -\/ Command FIFO is Full
\item Bit 3\+: CMDOVF -\/ Command FIFO overflow; write 1 to clear
\item Bit 4\+: WRE -\/ Write FIFO is Empty
\item Bit 5\+: WRF -\/ Write FIFO is Full
\item Bit 6\+: WROVF -\/ Write FIFO overflow; write 1 to clear
\item Bit 7\+: RDE -\/ Read FIFO is Empty
\item Bit 8\+: RDF -\/ Read FIFO is Full
\item Bits \mbox{[}9-\/31\mbox{]}\+: Reserved.
\end{DoxyItemize}

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} An $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$, which points to the base memory address of I2C registers.$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE$\ast$$\ast$ is a structure that contains the I2C registers.
\item {\ttfamily im\+\_\+value} A pointer to a 32-\/bit variable where the interrupt mask value will be stored.
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md22}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+get\+MIS$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md22}
{\itshape Reads the Masked Interrupt Status (MIS) register.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_aa87448a542b497393695dca2acc6d6b8}{EF\_I2C\_getMIS}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ uint32\_t\ *mis\_value}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function reads the masked interrupt status register (MIS) of the I2C peripheral. MIS Register Breakdown$\ast$$\ast$\+:


\begin{DoxyItemize}
\item Bit 0\+: MISS\+\_\+\+ACK -\/ Slave ACK is missed
\item Bit 1\+: CMDE -\/ Command FIFO is Empty
\item Bit 2\+: CMDF -\/ Command FIFO is Full
\item Bit 3\+: CMDOVF -\/ Command FIFO overflow; write 1 to clear
\item Bit 4\+: WRE -\/ Write FIFO is Empty
\item Bit 5\+: WRF -\/ Write FIFO is Full
\item Bit 6\+: WROVF -\/ Write FIFO overflow; write 1 to clear
\item Bit 7\+: RDE -\/ Read FIFO is Empty
\item Bit 8\+: RDF -\/ Read FIFO is Full
\item Bits \mbox{[}9-\/31\mbox{]}\+: Reserved.
\end{DoxyItemize}

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} An $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$, which points to the base memory address of I2C registers.$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE$\ast$$\ast$ is a structure that contains the I2C registers.
\item {\ttfamily mis\+\_\+value} A pointer to a 32-\/bit variable where the masked interrupt status will be stored.
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md23}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+get\+Prescaler$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md23}
{\itshape Gets the I2C prescaler value.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a8fa9bab21502620a499c6f943fc69c4c}{EF\_I2C\_getPrescaler}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ uint32\_t\ *prescaler\_value}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function reads the current prescaler value from the I2C peripheral. The prescaler determines the clock frequency for the I2C communication.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} An $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$, which points to the base memory address of I2C registers.$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE$\ast$$\ast$ is a structure that contains the I2C registers.
\item {\ttfamily prescaler\+\_\+value} A pointer to a 32-\/bit variable where the current prescaler value will be stored.
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md24}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+get\+RIS$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md24}
{\itshape Reads the Raw Interrupt Status (RIS) register.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a8efd0e0e84b49d60edbea6c2513929a5}{EF\_I2C\_getRIS}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ uint32\_t\ *ris\_value}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function reads the raw interrupt status register (RIS) of the I2C peripheral. The RIS register provides raw interrupt status flags indicating various conditions within the I2C communication. These flags include information such as FIFO states and errors.

RIS Register Breakdown$\ast$$\ast$\+:


\begin{DoxyItemize}
\item Bit 0\+: MISS\+\_\+\+ACK -\/ Slave ACK is missed
\item Bit 1\+: CMDE -\/ Command FIFO is Empty
\item Bit 2\+: CMDF -\/ Command FIFO is Full
\item Bit 3\+: CMDOVF -\/ Command FIFO overflow; write 1 to clear
\item Bit 4\+: WRE -\/ Write FIFO is Empty
\item Bit 5\+: WRF -\/ Write FIFO is Full
\item Bit 6\+: WROVF -\/ Write FIFO overflow; write 1 to clear
\item Bit 7\+: RDE -\/ Read FIFO is Empty
\item Bit 8\+: RDF -\/ Read FIFO is Full
\item Bits \mbox{[}9-\/31\mbox{]}\+: Reserved.
\end{DoxyItemize}

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} An $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$, which points to the base memory address of I2C registers.$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE$\ast$$\ast$ is a structure that contains the I2C registers.
\item {\ttfamily ris\+\_\+value} A pointer to a 32-\/bit variable where the raw interrupt status will be stored.
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md25}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+is\+Busy$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md25}
{\itshape Checks if the I2C peripheral is busy.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a69c76d64d9e2e6d29d53026b0fa1055c}{EF\_I2C\_isBusy}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ *is\_busy}
\DoxyCodeLine{)\ }

\end{DoxyCode}


! Sets the Interrupt Clear (ICR) register. $\ast$!

This function checks the {\ttfamily STATUS} register of the I2C peripheral to determine if the bus is currently busy. The result is stored in the memory location pointed to by{\ttfamily is\+\_\+busy}.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily is\+\_\+busy} Pointer to a boolean where the busy status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: I2C is busy.
\item {\ttfamily false}\+: I2C is idle.
\end{DoxyItemize}
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type EF\+\_\+\+DRIVER\+\_\+\+STATUS\+:


\begin{DoxyItemize}
\item EF\+\_\+\+DRIVER\+\_\+\+OK\+: The operation completed successfully.
\item EF\+\_\+\+DRIVER\+\_\+\+ERROR\+\_\+\+PARAMETER\+: {\ttfamily i2c} or{\ttfamily is\+\_\+busy} is NULL. 
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md26}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+is\+Command\+FIFOAvailable$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md26}
{\itshape Checks if the command FIFO is available.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a14e5de684a330a987584ba5219bf8304}{EF\_I2C\_isCommandFIFOAvailable}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ *is\_available}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function checks the {\ttfamily STATUS} register of the I2C peripheral to determine if the command FIFO is not full and ready to accept new commands. The result is stored in the memory location pointed to by{\ttfamily is\+\_\+available}.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily is\+\_\+available} Pointer to a boolean where the availability status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: Command FIFO is available.
\item {\ttfamily false}\+: Command FIFO is full.
\end{DoxyItemize}
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md27}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+is\+Read\+FIFOAvailable$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md27}
{\itshape Checks if the read FIFO is available.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a463bfb817bed4b5d06308211df98c7b4}{EF\_I2C\_isReadFIFOAvailable}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ *is\_available}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function checks the {\ttfamily STATUS} register of the I2C peripheral to determine if the read FIFO is not empty and has data available to be read. The result is stored in the memory location pointed to by{\ttfamily is\+\_\+available}.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily is\+\_\+available} Pointer to a boolean where the availability status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: Read FIFO is available.
\item {\ttfamily false}\+: Read FIFO is empty.
\end{DoxyItemize}
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md28}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+is\+Write\+FIFOAvailable$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md28}
{\itshape Checks if the write FIFO is available.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_aba9df55dc50dffa193d8990d9d3354b3}{EF\_I2C\_isWriteFIFOAvailable}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ *is\_available}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function checks the {\ttfamily STATUS} register of the I2C peripheral to determine if the write FIFO is not full and ready to accept new data. The result is stored in the memory location pointed to by{\ttfamily is\+\_\+available}.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily is\+\_\+available} Pointer to a boolean where the availability status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: Write FIFO is available.
\item {\ttfamily false}\+: Write FIFO is full.
\end{DoxyItemize}
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md29}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+read\+Data\+From\+Read\+FIFO$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md29}
{\itshape Reads data from the I2C Read FIFO (blocking).} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_ac2d5590e0da84534bca5496836811664}{EF\_I2C\_readDataFromReadFIFO}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ *data}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function reads a single byte of data from the I2C Read FIFO. It blocks until the FIFO becomes available and validates the data read.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily data} Pointer to a variable where the read data byte will be stored.
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type EF\+\_\+\+DRIVER\+\_\+\+STATUS\+:


\begin{DoxyItemize}
\item EF\+\_\+\+DRIVER\+\_\+\+OK\+: The operation completed successfully.
\item EF\+\_\+\+DRIVER\+\_\+\+ERROR\+\_\+\+PARAMETER\+: {\ttfamily i2c} or{\ttfamily data} is NULL.
\item EF\+\_\+\+DRIVER\+\_\+\+ERROR\+\_\+\+I2\+C\+\_\+\+INVALID\+\_\+\+DATA\+: The data read is invalid. 
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md30}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+read\+Data\+From\+Read\+FIFONon\+Blocking$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md30}
{\itshape Reads data from the I2C Read FIFO (non-\/blocking).} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a1c701c4aecb1bc623f530674337ba608}{EF\_I2C\_readDataFromReadFIFONonBlocking}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ *data,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ *data\_read}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function attempts to read a single byte of data from the I2C Read FIFO. If the FIFO is unavailable, the function returns immediately. The validity of the data is also checked.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily data} Pointer to a variable where the read data byte will be stored.
\item {\ttfamily data\+\_\+read} Pointer to a boolean where the read status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: Data was read successfully and is valid.
\item {\ttfamily false}\+: Read FIFO was unavailable or data is invalid.
\end{DoxyItemize}
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type EF\+\_\+\+DRIVER\+\_\+\+STATUS\+:


\begin{DoxyItemize}
\item EF\+\_\+\+DRIVER\+\_\+\+OK\+: The operation completed successfully.
\item EF\+\_\+\+DRIVER\+\_\+\+ERROR\+\_\+\+PARAMETER\+: {\ttfamily i2c},{\ttfamily data}, or{\ttfamily data\+\_\+read} is NULL.
\item EF\+\_\+\+DRIVER\+\_\+\+ERROR\+\_\+\+I2\+C\+\_\+\+INVALID\+\_\+\+DATA\+: The data read is invalid. 
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md31}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+receive\+Byte$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md31}
{\itshape Receives a single byte from a specified I2C address (blocking).} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a60288fe0351fce34b2872e31f1c9951b}{EF\_I2C\_receiveByte}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ *data,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ addr}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function reads a single byte from a specified I2C address. It blocks until all operations (read command, stop command, and data retrieval) are completed.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily data} Pointer to a char where the received data byte will be stored.
\item {\ttfamily addr} I2C address from which the data will be read.
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md32}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+receive\+Byte\+Non\+Blocking$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md32}
{\itshape Receives a single byte from a specified I2C address (non-\/blocking).} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a1789020facae10eb7788fae74ccc3bc8}{EF\_I2C\_receiveByteNonBlocking}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ *data,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ addr,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ *received}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function attempts to read a single byte from a specified I2C address in a non-\/blocking manner. If any step of the process (read command, stop command, or data retrieval) cannot complete immediately, the function returns.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily data} Pointer to a char where the received data byte will be stored.
\item {\ttfamily addr} I2C address from which the data will be read.
\item {\ttfamily received} Pointer to a boolean where the reception status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: Data was received successfully.
\item {\ttfamily false}\+: Reception could not be completed.
\end{DoxyItemize}
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md33}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+recieve\+Char\+Arr$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md33}
{\itshape Receives an array of characters from a specified I2C address (blocking).} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a774873c939f5d172d92a6587298deb5d}{EF\_I2C\_recieveCharArr}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ *data,}
\DoxyCodeLine{\ \ \ \ uint32\_t\ data\_length,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ addr}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function reads an array of characters from a specified I2C address. It issues the read command for each byte, stores the data in the provided buffer, and sends a stop command after successful reception.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily data} Pointer to the buffer where the received characters will be stored.
\item {\ttfamily data\+\_\+length} Number of characters to receive.
\item {\ttfamily addr} I2C address from which the data will be read.
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md34}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+send\+Read\+Command$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md34}
{\itshape Sends a read command to the I2C device (blocking).} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a5a686c3ed733700ac19aa163b98023c9}{EF\_I2C\_sendReadCommand}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ addr}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function sends a read command to the I2C device at the specified address. It blocks until the command FIFO becomes available.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily addr} The I2C address of the target device.
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md35}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+send\+Read\+Command\+Non\+Blocking$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md35}
{\itshape Sends a read command to the I2C device (non-\/blocking).} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a62ef1d56f7cbc0c4fdc66551fbc6f882}{EF\_I2C\_sendReadCommandNonBlocking}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ addr,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ *command\_sent}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function attempts to send a read command to the I2C device at the specified address. If the command FIFO is unavailable, the function returns immediately.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily addr} The I2C address of the target device.
\item {\ttfamily command\+\_\+sent} Pointer to a boolean where the command status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: Command was sent successfully.
\item {\ttfamily false}\+: Command FIFO was unavailable.
\end{DoxyItemize}
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md36}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+send\+Start\+Command$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md36}
{\itshape Sends a start condition on the I2C bus (blocking).} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_ad1fa3cec145bfbd8027e0370137c1b9d}{EF\_I2C\_sendStartCommand}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function sends a start condition on the I2C bus. It blocks until the command FIFO becomes available.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md37}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+send\+Start\+Command\+Non\+Blocking$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md37}
{\itshape Sends a start condition on the I2C bus (non-\/blocking).} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a5895919e916705ee1082efade9f1488e}{EF\_I2C\_sendStartCommandNonBlocking}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ *command\_sent}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function attempts to send a start condition on the I2C bus. If the command FIFO is unavailable, the function returns immediately.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily command\+\_\+sent} Pointer to a boolean where the command status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: Start condition was sent successfully.
\item {\ttfamily false}\+: Command FIFO was unavailable.
\end{DoxyItemize}
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md38}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+send\+Stop\+Command$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md38}
{\itshape Sends a stop condition on the I2C bus (blocking).} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a4545f7e33e2e35e7b100b6f3857433bd}{EF\_I2C\_sendStopCommand}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function sends a stop condition on the I2C bus. It blocks until the command FIFO becomes available.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md39}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+send\+Stop\+Command\+Non\+Blocking$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md39}
{\itshape Sends a stop condition on the I2C bus (non-\/blocking).} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_adc35bddf018b22d9f822442360d9a1e5}{EF\_I2C\_sendStopCommandNonBlocking}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ *command\_sent}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function attempts to send a stop condition on the I2C bus. If the command FIFO is unavailable, the function returns immediately.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily command\+\_\+sent} Pointer to a boolean where the command status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: Stop condition was sent successfully.
\item {\ttfamily false}\+: Command FIFO was unavailable.
\end{DoxyItemize}
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md40}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+send\+Write\+Command$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md40}
{\itshape Sends a write command to the I2C device (blocking).} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a0403b347e88030457b2681d17780b1e0}{EF\_I2C\_sendWriteCommand}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ addr}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function sends a write command to the I2C device at the specified address. It blocks until the command FIFO becomes available.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily addr} The I2C address of the target device.
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md41}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+send\+Write\+Command\+Non\+Blocking$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md41}
{\itshape Sends a write command to the I2C device (non-\/blocking).} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_ab809b36771601fc4fcc0ebe5b7c3c2b3}{EF\_I2C\_sendWriteCommandNonBlocking}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ addr,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ *command\_sent}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function attempts to send a write command to the I2C device at the specified address. If the command FIFO is unavailable, the function returns immediately.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily addr} The I2C address of the target device.
\item {\ttfamily command\+\_\+sent} Pointer to a boolean where the command status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: Command was sent successfully.
\item {\ttfamily false}\+: Command FIFO was unavailable.
\end{DoxyItemize}
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md42}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+send\+Write\+Multiple\+Command$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md42}
{\itshape Sends a \char`\"{}write multiple\char`\"{} command on the I2C bus (blocking).} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a8016d94edabbc9e56aa8632d81f93a4e}{EF\_I2C\_sendWriteMultipleCommand}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function sends a \char`\"{}write multiple\char`\"{} command on the I2C bus. It blocks until the command FIFO becomes available.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md43}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+send\+Write\+Multiple\+Command\+Non\+Blocking$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md43}
{\itshape Sends a \char`\"{}write multiple\char`\"{} command on the I2C bus (non-\/blocking).} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_aebf50811caef2dbdd664a60ade5c0514}{EF\_I2C\_sendWriteMultipleCommandNonBlocking}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ *command\_sent}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function attempts to send a \char`\"{}write multiple\char`\"{} command on the I2C bus. If the command FIFO is unavailable, the function returns immediately.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily command\+\_\+sent} Pointer to a boolean where the command status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: The \char`\"{}write multiple\char`\"{} command was sent successfully.
\item {\ttfamily false}\+: Command FIFO was unavailable.
\end{DoxyItemize}
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md44}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+set\+Command\+Reg$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md44}
{\itshape Sets the command register of the I2C controller.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a2286c60de589dcecb0fc78a48187440b}{EF\_I2C\_setCommandReg}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ uint32\_t\ value}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This ia a blocking function that writes a specified value directly to the I2C command register. It allows manual configuration of the I2C controller for advanced or custom operations.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} An $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$, which points to the base memory address of I2C registers.$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE$\ast$$\ast$ is a structure that contains the I2C registers.
\item {\ttfamily value} The 32-\/bit value to write to the I2C command register. This value typically contains specific bit fields to configure the I2C operation.
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md45}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+set\+Command\+Reg\+Non\+Blocking$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md45}
{\itshape Writes a command value to the I2C command register (non-\/blocking).} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_ac5ca754457eaaeeab83e607fd78039e9}{EF\_I2C\_setCommandRegNonBlocking}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ uint32\_t\ value,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ *command\_sent}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function attempts to write a specified command value to the I2C command register in a non-\/blocking manner. It checks the availability of the command FIFO before writing and updates the provided flag to indicate success.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily value} The command value to be written to the command register.
\item {\ttfamily command\+\_\+sent} Pointer to a boolean flag that indicates whether the command was successfully sent\+:
\begin{DoxyItemize}
\item true\+: Command was written successfully.
\item false\+: Command was not written (FIFO unavailable or error).
\end{DoxyItemize}
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md46}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+set\+Data\+Last$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md46}
{\itshape Sets the data last flag in the I2C data register.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a20ba0e48023589b93dc8fe15519c5482}{EF\_I2C\_setDataLast}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function modifies the data last flag in the I2C data register. The flag indicates whether the current data is the last in an I2C transaction.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} An $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$, which points to the base memory address of I2C registers.$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE$\ast$$\ast$ is a structure that contains the I2C registers.
\item {\ttfamily valid} A boolean value specifying the state of the data last flag. Set to {\ttfamily true} to mark the data as the last in the transaction, or{\ttfamily false} to clear the flag.
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md47}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+set\+Gclk\+Enable$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md47}
{\itshape Sets the GCLK enable bit in the I2C register to a certain value.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a8cd33e8dde8407bb760d8a9e06548dea}{EF\_I2C\_setGclkEnable}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ uint32\_t\ value}
\DoxyCodeLine{)\ }

\end{DoxyCode}


{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} An $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ , which points to the base memory address of I2C registers.$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE$\ast$$\ast$ is a structure that contains the I2C registers.
\item {\ttfamily value} The value of the GCLK enable bit
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md48}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+set\+IM$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md48}
{\itshape Sets the Interrupt Mask (IM) register.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_ac9a53ca41924b84ebf52d2b659c029c7}{EF\_I2C\_setIM}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ uint32\_t\ mask}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function writes a mask value to the interrupt mask register (IM) of the I2C peripheral. The IM register enables or disables the interrupt sources. The bits set in this register determine which interrupt sources generate masked interrupts. IM Register Breakdown$\ast$$\ast$\+:


\begin{DoxyItemize}
\item Bit 0\+: MISS\+\_\+\+ACK -\/ Slave ACK is missed
\item Bit 1\+: CMDE -\/ Command FIFO is Empty
\item Bit 2\+: CMDF -\/ Command FIFO is Full
\item Bit 3\+: CMDOVF -\/ Command FIFO overflow; write 1 to clear
\item Bit 4\+: WRE -\/ Write FIFO is Empty
\item Bit 5\+: WRF -\/ Write FIFO is Full
\item Bit 6\+: WROVF -\/ Write FIFO overflow; write 1 to clear
\item Bit 7\+: RDE -\/ Read FIFO is Empty
\item Bit 8\+: RDF -\/ Read FIFO is Full
\item Bits \mbox{[}9-\/31\mbox{]}\+: Reserved.
\end{DoxyItemize}

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} An $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$, which points to the base memory address of I2C registers.$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE$\ast$$\ast$ is a structure that contains the I2C registers.
\item {\ttfamily mask} A 32-\/bit mask value to be written to the IM register. Each bit corresponds to a specific interrupt source, with 1 enabling the interrupt and 0 disabling it.
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md49}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+set\+Prescaler$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md49}
{\itshape Sets the I2C prescaler value.} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a824f4aaa04cf1518f65a558c67172fdd}{EF\_I2C\_setPrescaler}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ uint32\_t\ value}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function sets the prescaler value for the I2C peripheral. The prescaler is used to configure the speed of the I2C communication by adjusting the clock frequency.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} An $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$, which points to the base memory address of I2C registers.$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE$\ast$$\ast$ is a structure that contains the I2C registers.
\item {\ttfamily value} The prescaler value to set for the I2C clock. This value determines the clock frequency for I2C communication.
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md50}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+transmit\+Byte$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md50}
{\itshape Transmits a single byte to a specified I2C address (blocking).} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a756e2b744dadf6851b99c5c2cf163938}{EF\_I2C\_transmitByte}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ data,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ addr}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function transmits a single byte to a specified I2C address using the Write FIFO. It blocks until all operations (data write, write command, and stop command) are completed.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily data} Data byte to be transmitted.
\item {\ttfamily addr} I2C address to which the data will be sent.
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md51}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+transmit\+Byte\+Non\+Blocking$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md51}
{\itshape Transmits a single byte to a specified I2C address (non-\/blocking).} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_acbe3b21327e821e4a28f9db978e6eaaa}{EF\_I2C\_transmitByteNonBlocking}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ data,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ addr,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ *transmitted}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function attempts to transmit a single byte to a specified I2C address using the Write FIFO in a non-\/blocking manner. If any step of the process (data write, write command, or stop command) cannot complete immediately, the function returns.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily data} Data byte to be transmitted.
\item {\ttfamily addr} I2C address to which the data will be sent.
\item {\ttfamily transmitted} Pointer to a boolean where the transmission status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: Data was transmitted successfully.
\item {\ttfamily false}\+: Transmission could not be completed.
\end{DoxyItemize}
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md52}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+transmit\+Char\+Arr$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md52}
{\itshape Transmits an array of characters to a specified I2C address (blocking).} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a4b3ffb782170b3f8a621ad3ca9fade8e}{EF\_I2C\_transmitCharArr}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ *data,}
\DoxyCodeLine{\ \ \ \ uint32\_t\ data\_length,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ addr}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function sends an array of characters to a specified I2C address. It handles writing the data to the I2C FIFO and ensures the last byte is appropriately marked.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily data} Pointer to the array of characters to be transmitted.
\item {\ttfamily data\+\_\+length} Number of characters in the array to transmit.
\item {\ttfamily addr} I2C address to which the data will be sent.
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md53}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+write\+Data\+To\+Write\+FIFO$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md53}
{\itshape Writes data to the I2C Write FIFO (blocking).} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a976c6f1e98d2dfbf0cc9bf31bab0b110}{EF\_I2C\_writeDataToWriteFIFO}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ data}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function writes a single byte of data to the I2C Write FIFO. It blocks until the FIFO becomes available.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily data} Data byte to be written to the FIFO.
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code \hypertarget{md__r_e_a_d_m_e_autotoc_md54}{}\doxysubsection{function $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+write\+Data\+To\+Write\+FIFONon\+Blocking$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md54}
{\itshape Writes data to the I2C Write FIFO (non-\/blocking).} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{_e_f___driver___common_8h_ad1c99136d1edfd0a7757f5b81600a351}{EF\_DRIVER\_STATUS}}\ \mbox{\hyperlink{_e_f___i2_c_8c_a5908b86c6c3a5c276472e1a70fadbbd4}{EF\_I2C\_writeDataToWriteFIFONonBlocking}}\ (}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE\_PTR}}\ i2c,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{char}\ data,}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ *data\_written}
\DoxyCodeLine{)\ }

\end{DoxyCode}


This function attempts to write a single byte of data to the I2C Write FIFO. If the FIFO is unavailable, the function returns immediately.

{\bfseries{Parameters\+:}}


\begin{DoxyItemize}
\item {\ttfamily i2c} Pointer to the I2C base address structure $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$.
\item {\ttfamily data} Data byte to be written to the FIFO.
\item {\ttfamily data\+\_\+written} Pointer to a boolean where the write status will be stored\+:
\begin{DoxyItemize}
\item {\ttfamily true}\+: The data was written successfully.
\item {\ttfamily false}\+: Write FIFO was unavailable.
\end{DoxyItemize}
\end{DoxyItemize}

{\bfseries{Returns\+:}}

status A value of type $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+DRIVER\textbackslash{}\+\_\+\+STATUS$\ast$$\ast$ \+: returns a success or error code\hypertarget{md__r_e_a_d_m_e_autotoc_md55}{}\doxysection{File EF\+\_\+\+I2\+C\+\_\+regs.\+h}\label{md__r_e_a_d_m_e_autotoc_md55}
\hypertarget{md__r_e_a_d_m_e_autotoc_md56}{}\doxysection{Structures and Types}\label{md__r_e_a_d_m_e_autotoc_md56}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\raggedleft \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\cellcolor{\tableheadbgcolor}\textbf{ Name    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\raggedleft \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\cellcolor{\tableheadbgcolor}\textbf{ Name    }\\\cline{1-2}
\endhead
\PBS\raggedleft typedef struct $\ast$$\ast$\textbackslash{}\+\_\+\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+$\ast$$\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE$\ast$$\ast$ ~\newline
    \\\cline{1-2}
\PBS\raggedleft typedef $\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE$\ast$$\ast$ $\ast$   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+\+PTR$\ast$$\ast$ ~\newline
    \\\cline{1-2}
\PBS\raggedleft struct   &$\ast$$\ast$\textbackslash{}\+\_\+\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+TYPE\textbackslash{}\+\_\+$\ast$$\ast$ ~\newline
   \\\cline{1-2}
\end{longtabu}
\hypertarget{md__r_e_a_d_m_e_autotoc_md57}{}\doxysection{Macros}\label{md__r_e_a_d_m_e_autotoc_md57}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\raggedleft \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\cellcolor{\tableheadbgcolor}\textbf{ Name    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\raggedleft \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\cellcolor{\tableheadbgcolor}\textbf{ Name    }\\\cline{1-2}
\endhead
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+CMDE\textbackslash{}\+\_\+\+FLAG$\ast$$\ast$ ((uint32\+\_\+t)0x2)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+CMDF\textbackslash{}\+\_\+\+FLAG$\ast$$\ast$ ((uint32\+\_\+t)0x4)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+CMDOVF\textbackslash{}\+\_\+\+FLAG$\ast$$\ast$ ((uint32\+\_\+t)0x8)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+COMMAND\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+CMD\textbackslash{}\+\_\+\+ADDRESS\textbackslash{}\+\_\+\+BIT$\ast$$\ast$ ((uint32\+\_\+t)0)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+COMMAND\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+CMD\textbackslash{}\+\_\+\+ADDRESS\textbackslash{}\+\_\+\+MASK$\ast$$\ast$ ((uint32\+\_\+t)0x7f)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+COMMAND\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+CMD\textbackslash{}\+\_\+\+READ\textbackslash{}\+\_\+\+BIT$\ast$$\ast$ ((uint32\+\_\+t)9)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+COMMAND\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+CMD\textbackslash{}\+\_\+\+READ\textbackslash{}\+\_\+\+MASK$\ast$$\ast$ ((uint32\+\_\+t)0x200)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+COMMAND\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+CMD\textbackslash{}\+\_\+\+START\textbackslash{}\+\_\+\+BIT$\ast$$\ast$ ((uint32\+\_\+t)8)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+COMMAND\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+CMD\textbackslash{}\+\_\+\+START\textbackslash{}\+\_\+\+MASK$\ast$$\ast$ ((uint32\+\_\+t)0x100)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+COMMAND\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+CMD\textbackslash{}\+\_\+\+STOP\textbackslash{}\+\_\+\+BIT$\ast$$\ast$ ((uint32\+\_\+t)12)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+COMMAND\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+CMD\textbackslash{}\+\_\+\+STOP\textbackslash{}\+\_\+\+MASK$\ast$$\ast$ ((uint32\+\_\+t)0x1000)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+COMMAND\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+CMD\textbackslash{}\+\_\+\+WRITE\textbackslash{}\+\_\+\+BIT$\ast$$\ast$ ((uint32\+\_\+t)10)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+COMMAND\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+CMD\textbackslash{}\+\_\+\+WRITE\textbackslash{}\+\_\+\+MASK$\ast$$\ast$ ((uint32\+\_\+t)0x400)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+COMMAND\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+CMD\textbackslash{}\+\_\+\+WRITE\textbackslash{}\+\_\+\+MULTIPLE\textbackslash{}\+\_\+\+BIT$\ast$$\ast$ ((uint32\+\_\+t)11)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+COMMAND\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+CMD\textbackslash{}\+\_\+\+WRITE\textbackslash{}\+\_\+\+MULTIPLE\textbackslash{}\+\_\+\+MASK$\ast$$\ast$ ((uint32\+\_\+t)0x800)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+DATA\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+DATA\textbackslash{}\+\_\+\+BIT$\ast$$\ast$ ((uint32\+\_\+t)0)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+DATA\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+DATA\textbackslash{}\+\_\+\+LAST\textbackslash{}\+\_\+\+BIT$\ast$$\ast$ ((uint32\+\_\+t)9)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+DATA\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+DATA\textbackslash{}\+\_\+\+LAST\textbackslash{}\+\_\+\+MASK$\ast$$\ast$ ((uint32\+\_\+t)0x200)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+DATA\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+DATA\textbackslash{}\+\_\+\+MASK$\ast$$\ast$ ((uint32\+\_\+t)0xff)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+DATA\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+DATA\textbackslash{}\+\_\+\+VALID\textbackslash{}\+\_\+\+BIT$\ast$$\ast$ ((uint32\+\_\+t)8)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+DATA\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+DATA\textbackslash{}\+\_\+\+VALID\textbackslash{}\+\_\+\+MASK$\ast$$\ast$ ((uint32\+\_\+t)0x100)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+MISS\textbackslash{}\+\_\+\+ACK\textbackslash{}\+\_\+\+FLAG$\ast$$\ast$ ((uint32\+\_\+t)0x1)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+RDE\textbackslash{}\+\_\+\+FLAG$\ast$$\ast$ ((uint32\+\_\+t)0x80)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+RDF\textbackslash{}\+\_\+\+FLAG$\ast$$\ast$ ((uint32\+\_\+t)0x100)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+BUSY\textbackslash{}\+\_\+\+BIT$\ast$$\ast$ ((uint32\+\_\+t)0)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+BUSY\textbackslash{}\+\_\+\+MASK$\ast$$\ast$ ((uint32\+\_\+t)0x1)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+BUS\textbackslash{}\+\_\+\+ACT\textbackslash{}\+\_\+\+BIT$\ast$$\ast$ ((uint32\+\_\+t)2)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+BUS\textbackslash{}\+\_\+\+ACT\textbackslash{}\+\_\+\+MASK$\ast$$\ast$ ((uint32\+\_\+t)0x4)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+BUS\textbackslash{}\+\_\+\+CONT\textbackslash{}\+\_\+\+BIT$\ast$$\ast$ ((uint32\+\_\+t)1)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+BUS\textbackslash{}\+\_\+\+CONT\textbackslash{}\+\_\+\+MASK$\ast$$\ast$ ((uint32\+\_\+t)0x2)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+CMD\textbackslash{}\+\_\+\+EMPTY\textbackslash{}\+\_\+\+BIT$\ast$$\ast$ ((uint32\+\_\+t)8)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+CMD\textbackslash{}\+\_\+\+EMPTY\textbackslash{}\+\_\+\+MASK$\ast$$\ast$ ((uint32\+\_\+t)0x100)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+CMD\textbackslash{}\+\_\+\+FULL\textbackslash{}\+\_\+\+BIT$\ast$$\ast$ ((uint32\+\_\+t)9)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+CMD\textbackslash{}\+\_\+\+FULL\textbackslash{}\+\_\+\+MASK$\ast$$\ast$ ((uint32\+\_\+t)0x200)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+CMD\textbackslash{}\+\_\+\+OVF\textbackslash{}\+\_\+\+BIT$\ast$$\ast$ ((uint32\+\_\+t)10)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+CMD\textbackslash{}\+\_\+\+OVF\textbackslash{}\+\_\+\+MASK$\ast$$\ast$ ((uint32\+\_\+t)0x400)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+MISS\textbackslash{}\+\_\+\+ACK\textbackslash{}\+\_\+\+BIT$\ast$$\ast$ ((uint32\+\_\+t)3)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+MISS\textbackslash{}\+\_\+\+ACK\textbackslash{}\+\_\+\+MASK$\ast$$\ast$ ((uint32\+\_\+t)0x8)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+RD\textbackslash{}\+\_\+\+EMPTY\textbackslash{}\+\_\+\+BIT$\ast$$\ast$ ((uint32\+\_\+t)14)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+RD\textbackslash{}\+\_\+\+EMPTY\textbackslash{}\+\_\+\+MASK$\ast$$\ast$ ((uint32\+\_\+t)0x4000)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+RD\textbackslash{}\+\_\+\+FULL\textbackslash{}\+\_\+\+BIT$\ast$$\ast$ ((uint32\+\_\+t)15)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+RD\textbackslash{}\+\_\+\+FULL\textbackslash{}\+\_\+\+MASK$\ast$$\ast$ ((uint32\+\_\+t)0x8000)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+WR\textbackslash{}\+\_\+\+EMPTY\textbackslash{}\+\_\+\+BIT$\ast$$\ast$ ((uint32\+\_\+t)11)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+WR\textbackslash{}\+\_\+\+EMPTY\textbackslash{}\+\_\+\+MASK$\ast$$\ast$ ((uint32\+\_\+t)0x800)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+WR\textbackslash{}\+\_\+\+FULL\textbackslash{}\+\_\+\+BIT$\ast$$\ast$ ((uint32\+\_\+t)12)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+WR\textbackslash{}\+\_\+\+FULL\textbackslash{}\+\_\+\+MASK$\ast$$\ast$ ((uint32\+\_\+t)0x1000)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+WR\textbackslash{}\+\_\+\+OVF\textbackslash{}\+\_\+\+BIT$\ast$$\ast$ ((uint32\+\_\+t)13)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+STATUS\textbackslash{}\+\_\+\+REG\textbackslash{}\+\_\+\+WR\textbackslash{}\+\_\+\+OVF\textbackslash{}\+\_\+\+MASK$\ast$$\ast$ ((uint32\+\_\+t)0x2000)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+WRE\textbackslash{}\+\_\+\+FLAG$\ast$$\ast$ ((uint32\+\_\+t)0x10)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+WRF\textbackslash{}\+\_\+\+FLAG$\ast$$\ast$ ((uint32\+\_\+t)0x20)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+EF\textbackslash{}\+\_\+\+I2C\textbackslash{}\+\_\+\+WROVF\textbackslash{}\+\_\+\+FLAG$\ast$$\ast$ ((uint32\+\_\+t)0x40)~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\+IO\textbackslash{}\+\_\+\+TYPES$\ast$$\ast$ ~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\textbackslash{}\+\_\+\textbackslash{}\+\_\+R$\ast$$\ast$ volatile const uint32\+\_\+t~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\textbackslash{}\+\_\+\textbackslash{}\+\_\+\+RW$\ast$$\ast$ volatile uint32\+\_\+t~\newline
    \\\cline{1-2}
\PBS\raggedleft define   &$\ast$$\ast$\textbackslash{}\+\_\+\textbackslash{}\+\_\+W$\ast$$\ast$ volatile uint32\+\_\+t~\newline
   \\\cline{1-2}
\end{longtabu}
\hypertarget{md__r_e_a_d_m_e_autotoc_md58}{}\doxysection{Structures and Types Documentation}\label{md__r_e_a_d_m_e_autotoc_md58}
\hypertarget{md__r_e_a_d_m_e_autotoc_md59}{}\doxysubsection{typedef $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+TYPE$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md59}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef}\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{\_EF\_I2C\_TYPE\_}}\ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE}};}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md60}{}\doxysubsection{typedef $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+\+PTR$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md60}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef}\ \mbox{\hyperlink{struct___e_f___i2_c___t_y_p_e__}{EF\_I2C\_TYPE}}*\ \mbox{\hyperlink{_e_f___i2_c__regs_8h_aa2269a016ba045981b24348570da1bbe}{EF\_I2C\_TYPE\_PTR}};}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md61}{}\doxysubsection{struct $<$tt$>$\+\_\+\+EF\+\_\+\+I2\+C\+\_\+\+TYPE\+\_\+$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md61}
Variables\+:


\begin{DoxyItemize}
\item $\ast$$\ast$\textbackslash{}\+\_\+\textbackslash{}\+\_\+W$\ast$$\ast$ COMMAND ~\newline

\item $\ast$$\ast$\textbackslash{}\+\_\+\textbackslash{}\+\_\+\+RW$\ast$$\ast$ DATA ~\newline

\item $\ast$$\ast$\textbackslash{}\+\_\+\textbackslash{}\+\_\+W$\ast$$\ast$ GCLK ~\newline

\item $\ast$$\ast$\textbackslash{}\+\_\+\textbackslash{}\+\_\+\+RW$\ast$$\ast$ IM ~\newline

\item $\ast$$\ast$\textbackslash{}\+\_\+\textbackslash{}\+\_\+R$\ast$$\ast$ MIS ~\newline

\item $\ast$$\ast$\textbackslash{}\+\_\+\textbackslash{}\+\_\+W$\ast$$\ast$ PR ~\newline

\item $\ast$$\ast$\textbackslash{}\+\_\+\textbackslash{}\+\_\+R$\ast$$\ast$ RIS ~\newline

\item $\ast$$\ast$\textbackslash{}\+\_\+\textbackslash{}\+\_\+R$\ast$$\ast$ STATUS ~\newline

\item $\ast$$\ast$\textbackslash{}\+\_\+\textbackslash{}\+\_\+R$\ast$$\ast$ reserved\+\_\+1 ~\newline

\item $\ast$$\ast$\textbackslash{}\+\_\+\textbackslash{}\+\_\+R$\ast$$\ast$ reserved\+\_\+2 ~\newline

\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md62}{}\doxysection{Macros Documentation}\label{md__r_e_a_d_m_e_autotoc_md62}
\hypertarget{md__r_e_a_d_m_e_autotoc_md63}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+CMDE\+\_\+\+FLAG$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md63}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_CMDE\_FLAG\ ((uint32\_t)0x2)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md64}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+CMDF\+\_\+\+FLAG$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md64}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_CMDF\_FLAG\ ((uint32\_t)0x4)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md65}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+CMDOVF\+\_\+\+FLAG$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md65}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_CMDOVF\_FLAG\ ((uint32\_t)0x8)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md66}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+COMMAND\+\_\+\+REG\+\_\+\+CMD\+\_\+\+ADDRESS\+\_\+\+BIT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md66}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_COMMAND\_REG\_CMD\_ADDRESS\_BIT\ ((uint32\_t)0)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md67}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+COMMAND\+\_\+\+REG\+\_\+\+CMD\+\_\+\+ADDRESS\+\_\+\+MASK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md67}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_COMMAND\_REG\_CMD\_ADDRESS\_MASK\ ((uint32\_t)0x7f)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md68}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+COMMAND\+\_\+\+REG\+\_\+\+CMD\+\_\+\+READ\+\_\+\+BIT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md68}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_COMMAND\_REG\_CMD\_READ\_BIT\ ((uint32\_t)9)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md69}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+COMMAND\+\_\+\+REG\+\_\+\+CMD\+\_\+\+READ\+\_\+\+MASK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md69}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_COMMAND\_REG\_CMD\_READ\_MASK\ ((uint32\_t)0x200)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md70}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+COMMAND\+\_\+\+REG\+\_\+\+CMD\+\_\+\+START\+\_\+\+BIT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md70}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_COMMAND\_REG\_CMD\_START\_BIT\ ((uint32\_t)8)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md71}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+COMMAND\+\_\+\+REG\+\_\+\+CMD\+\_\+\+START\+\_\+\+MASK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md71}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_COMMAND\_REG\_CMD\_START\_MASK\ ((uint32\_t)0x100)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md72}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+COMMAND\+\_\+\+REG\+\_\+\+CMD\+\_\+\+STOP\+\_\+\+BIT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md72}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_COMMAND\_REG\_CMD\_STOP\_BIT\ ((uint32\_t)12)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md73}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+COMMAND\+\_\+\+REG\+\_\+\+CMD\+\_\+\+STOP\+\_\+\+MASK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md73}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_COMMAND\_REG\_CMD\_STOP\_MASK\ ((uint32\_t)0x1000)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md74}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+COMMAND\+\_\+\+REG\+\_\+\+CMD\+\_\+\+WRITE\+\_\+\+BIT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md74}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_COMMAND\_REG\_CMD\_WRITE\_BIT\ ((uint32\_t)10)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md75}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+COMMAND\+\_\+\+REG\+\_\+\+CMD\+\_\+\+WRITE\+\_\+\+MASK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md75}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_COMMAND\_REG\_CMD\_WRITE\_MASK\ ((uint32\_t)0x400)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md76}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+COMMAND\+\_\+\+REG\+\_\+\+CMD\+\_\+\+WRITE\+\_\+\+MULTIPLE\+\_\+\+BIT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md76}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_COMMAND\_REG\_CMD\_WRITE\_MULTIPLE\_BIT\ ((uint32\_t)11)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md77}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+COMMAND\+\_\+\+REG\+\_\+\+CMD\+\_\+\+WRITE\+\_\+\+MULTIPLE\+\_\+\+MASK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md77}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_COMMAND\_REG\_CMD\_WRITE\_MULTIPLE\_MASK\ ((uint32\_t)0x800)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md78}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+DATA\+\_\+\+REG\+\_\+\+DATA\+\_\+\+BIT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md78}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_DATA\_REG\_DATA\_BIT\ ((uint32\_t)0)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md79}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+DATA\+\_\+\+REG\+\_\+\+DATA\+\_\+\+LAST\+\_\+\+BIT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md79}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_DATA\_REG\_DATA\_LAST\_BIT\ ((uint32\_t)9)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md80}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+DATA\+\_\+\+REG\+\_\+\+DATA\+\_\+\+LAST\+\_\+\+MASK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md80}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_DATA\_REG\_DATA\_LAST\_MASK\ ((uint32\_t)0x200)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md81}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+DATA\+\_\+\+REG\+\_\+\+DATA\+\_\+\+MASK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md81}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_DATA\_REG\_DATA\_MASK\ ((uint32\_t)0xff)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md82}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+DATA\+\_\+\+REG\+\_\+\+DATA\+\_\+\+VALID\+\_\+\+BIT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md82}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_DATA\_REG\_DATA\_VALID\_BIT\ ((uint32\_t)8)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md83}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+DATA\+\_\+\+REG\+\_\+\+DATA\+\_\+\+VALID\+\_\+\+MASK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md83}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_DATA\_REG\_DATA\_VALID\_MASK\ ((uint32\_t)0x100)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md84}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+MISS\+\_\+\+ACK\+\_\+\+FLAG$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md84}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_MISS\_ACK\_FLAG\ ((uint32\_t)0x1)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md85}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+RDE\+\_\+\+FLAG$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md85}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_RDE\_FLAG\ ((uint32\_t)0x80)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md86}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+RDF\+\_\+\+FLAG$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md86}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_RDF\_FLAG\ ((uint32\_t)0x100)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md87}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+BUSY\+\_\+\+BIT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md87}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_BUSY\_BIT\ ((uint32\_t)0)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md88}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+BUSY\+\_\+\+MASK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md88}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_BUSY\_MASK\ ((uint32\_t)0x1)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md89}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+BUS\+\_\+\+ACT\+\_\+\+BIT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md89}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_BUS\_ACT\_BIT\ ((uint32\_t)2)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md90}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+BUS\+\_\+\+ACT\+\_\+\+MASK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md90}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_BUS\_ACT\_MASK\ ((uint32\_t)0x4)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md91}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+BUS\+\_\+\+CONT\+\_\+\+BIT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md91}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_BUS\_CONT\_BIT\ ((uint32\_t)1)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md92}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+BUS\+\_\+\+CONT\+\_\+\+MASK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md92}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_BUS\_CONT\_MASK\ ((uint32\_t)0x2)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md93}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+CMD\+\_\+\+EMPTY\+\_\+\+BIT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md93}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_CMD\_EMPTY\_BIT\ ((uint32\_t)8)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md94}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+CMD\+\_\+\+EMPTY\+\_\+\+MASK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md94}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_CMD\_EMPTY\_MASK\ ((uint32\_t)0x100)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md95}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+CMD\+\_\+\+FULL\+\_\+\+BIT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md95}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_CMD\_FULL\_BIT\ ((uint32\_t)9)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md96}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+CMD\+\_\+\+FULL\+\_\+\+MASK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md96}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_CMD\_FULL\_MASK\ ((uint32\_t)0x200)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md97}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+CMD\+\_\+\+OVF\+\_\+\+BIT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md97}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_CMD\_OVF\_BIT\ ((uint32\_t)10)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md98}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+CMD\+\_\+\+OVF\+\_\+\+MASK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md98}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_CMD\_OVF\_MASK\ ((uint32\_t)0x400)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md99}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+MISS\+\_\+\+ACK\+\_\+\+BIT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md99}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_MISS\_ACK\_BIT\ ((uint32\_t)3)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md100}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+MISS\+\_\+\+ACK\+\_\+\+MASK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md100}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_MISS\_ACK\_MASK\ ((uint32\_t)0x8)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md101}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+RD\+\_\+\+EMPTY\+\_\+\+BIT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md101}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_RD\_EMPTY\_BIT\ ((uint32\_t)14)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md102}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+RD\+\_\+\+EMPTY\+\_\+\+MASK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md102}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_RD\_EMPTY\_MASK\ ((uint32\_t)0x4000)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md103}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+RD\+\_\+\+FULL\+\_\+\+BIT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md103}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_RD\_FULL\_BIT\ ((uint32\_t)15)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md104}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+RD\+\_\+\+FULL\+\_\+\+MASK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md104}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_RD\_FULL\_MASK\ ((uint32\_t)0x8000)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md105}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+WR\+\_\+\+EMPTY\+\_\+\+BIT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md105}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_WR\_EMPTY\_BIT\ ((uint32\_t)11)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md106}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+WR\+\_\+\+EMPTY\+\_\+\+MASK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md106}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_WR\_EMPTY\_MASK\ ((uint32\_t)0x800)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md107}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+WR\+\_\+\+FULL\+\_\+\+BIT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md107}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_WR\_FULL\_BIT\ ((uint32\_t)12)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md108}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+WR\+\_\+\+FULL\+\_\+\+MASK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md108}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_WR\_FULL\_MASK\ ((uint32\_t)0x1000)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md109}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+WR\+\_\+\+OVF\+\_\+\+BIT$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md109}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_WR\_OVF\_BIT\ ((uint32\_t)13)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md110}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+STATUS\+\_\+\+REG\+\_\+\+WR\+\_\+\+OVF\+\_\+\+MASK$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md110}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_STATUS\_REG\_WR\_OVF\_MASK\ ((uint32\_t)0x2000)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md111}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+WRE\+\_\+\+FLAG$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md111}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_WRE\_FLAG\ ((uint32\_t)0x10)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md112}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+WRF\+\_\+\+FLAG$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md112}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_WRF\_FLAG\ ((uint32\_t)0x20)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md113}{}\doxysubsection{define $<$tt$>$\+EF\+\_\+\+I2\+C\+\_\+\+WROVF\+\_\+\+FLAG$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md113}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ EF\_I2C\_WROVF\_FLAG\ ((uint32\_t)0x40)}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md114}{}\doxysubsection{define $<$tt$>$\+IO\+\_\+\+TYPES$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md114}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ IO\_TYPES\ }}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md115}{}\doxysubsection{define $<$tt$>$\+\_\+\+\_\+\+R$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md115}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ \_\_R\ volatile\ const\ uint32\_t}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md116}{}\doxysubsection{define $<$tt$>$\+\_\+\+\_\+\+RW$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md116}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ \_\_RW\ volatile\ \ \ \ \ \ \ uint32\_t}}

\end{DoxyCode}
\hypertarget{md__r_e_a_d_m_e_autotoc_md117}{}\doxysubsection{define $<$tt$>$\+\_\+\+\_\+\+W$<$/tt$>$}\label{md__r_e_a_d_m_e_autotoc_md117}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ \_\_W\ volatile\ \ \ \ \ \ \ uint32\_t}}

\end{DoxyCode}
 